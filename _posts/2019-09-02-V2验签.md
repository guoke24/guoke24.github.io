---
layout:     post
title:      "Android V2 验签-源码角度"
subtitle:   "read the fxxking source code"
date:       2019-09-29 12:00:00
author:     "GuoHao"
header-img: "img/waittouse.jpg"
catalog: true
tags:
    - Android
    - 源码
    - 签名
---

# 杂谈
本月初写完了加签的文章后，拔了个智齿，疼痛的那几天（其实就第一天比较疼）都靠玩游戏度日，渐渐颓废，进而陷入了消费欲望的漩涡中不能自拔。

随后！决定花钱斩断物质的念头，就在中秋月圆之夜，花费巨款来让自己重新做人，毫不犹豫的购入2018 MacBook Pro 13.3，16g+512g的配置一步到位而不需要外挂固态硬盘，编译 Android 源码也是足够，最后特别一提的是深空灰的颜色，希望借此体现程序员那冷静深刻的一份锐利。

16号收到机器之后，磨磨蹭蹭的等到了19号才开箱，20号才开始断断续续的配置环境，其中又陷入了没有4K显示器而懊恼的小泥潭，要不要买床垫打底的思考，小爱音箱pro的研究等等杂事，花掉了很多时间！幡然醒悟后，突然就是现在，突然就是9月29号，我TM的几乎浪费了一个月的时间，毛事没做！身上的银两不知怎么就从8w变成了4w了。。。哈哈哈，真搞笑，历史又在重演！

而现在，我正坐在电脑前码字，其他的事情都变得模糊，这是契机！趁机写了这篇验签文章！因懊悔而行动，临时抱佛脚，在 deadline 线上挣扎，不正是人类的本性吗？

# 前言
月初写的这篇文章：[源码看 Android V2 签名之加签篇](https://guoke24.top/2019/09/02/V2加签/)，从源码的角度解析了加签的过程，同时也了解了签名 APK 的结构，
如下图：
![](http://guoke24.top/img/apk-before-after-signing.png)<br>  
![](http://127.0.0.1:4000/img/apk-before-after-signing.png)<br> 

还有签名块的结构，用类json格式表示如下：
```
apk
{
    beforeCentralDir,
    apkSigningBlock,// apk 签名分块
		{
		    blockSizeFieldValue,
		    pairSizeFieldValue,
		    APK_SIGNATURE_SCHEME_V2_BLOCK_ID,
		    apkSignatureSchemeV2Block，// value 值，内含 “ID-值”对，V2 分块
		    blockSizeFieldValue,
		    APK_SIGNING_BLOCK_MAGIC,
		}
    centralDir,
    eocd,
}
```
再来一张表格图示：  
![](http://guoke24.top/img/v2签名块表格图示.png)<br>


# V2 验签的入口

接着看源码，验签的代码都是在 framework 内的，可以通过该命令下载（可能需科学上网）：
```
git clone https://android.googlesource.com/platform/frameworks/base

```
也可以去网上浏览（可能需科学上网），直接[点击该链接](https://android.googlesource.com/platform/frameworks/base)；

我们先找 V2 验签的函数入口，这是在安装 APK 的调用链中，定义在该文件：
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java  
代码段1:
```
    private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
......
        try {
            // either use what we've been given or parse directly from the APK
            if (args.signingDetails != PackageParser.SigningDetails.UNKNOWN) {
                pkg.setSigningDetails(args.signingDetails);
            } else {
                PackageParser.collectCertificates(pkg, false /* skipVerify */);
            }
        } catch (PackageParserException e) {
            res.setError("Failed collect during installPackageLI", e);
            return;
        }
......
    }
```

接着执行 PackageParser 类的 collectCertificates 函数，  
进入文件：  
/frameworks/base/core/java/android/content/pm/PackageParser.java  
代码段2:
```
    /**
     * Collect certificates from all the APKs described in the given package,
     * populating {@link Package#mSigningDetails}. Also asserts that all APK
     * contents are signed correctly and consistently.
     */
    public static void collectCertificates(Package pkg, boolean skipVerify)
            throws PackageParserException {
        collectCertificatesInternal(pkg, skipVerify);
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i < childCount; i++) {
            Package childPkg = pkg.childPackages.get(i);
            childPkg.mSigningDetails = pkg.mSigningDetails;
        }
    }



    private static void collectCertificatesInternal(Package pkg, boolean skipVerify)
            throws PackageParserException {
        pkg.mSigningDetails = SigningDetails.UNKNOWN;

        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "collectCertificates");
        try {
            collectCertificates(pkg, new File(pkg.baseCodePath), skipVerify);

            if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
                for (int i = 0; i < pkg.splitCodePaths.length; i++) {
                    collectCertificates(pkg, new File(pkg.splitCodePaths[i]), skipVerify);
                }
            }
        } finally {
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }
    }



    private static void collectCertificates(Package pkg, File apkFile, boolean skipVerify)
            throws PackageParserException {
        final String apkPath = apkFile.getAbsolutePath();

        int minSignatureScheme = SigningDetails.SignatureSchemeVersion.JAR;
        if (pkg.applicationInfo.isStaticSharedLibrary()) {
            // must use v2 signing scheme
            minSignatureScheme = SigningDetails.SignatureSchemeVersion.SIGNING_BLOCK_V2;
        }
        SigningDetails verified;
        if (skipVerify) {
            // systemDir APKs are already trusted, save time by not verifying
            verified = ApkSignatureVerifier.plsCertsNoVerifyOnlyCerts(
                        apkPath, minSignatureScheme);
        } else {
            // 2-1 APK 的验签入口
            verified = ApkSignatureVerifier.verify(apkPath, minSignatureScheme);
        }

        // Verify that entries are signed consistently with the first pkg
        // we encountered. Note that for splits, certificates may have
        // already been populated during an earlier parse of a base APK.
        if (pkg.mSigningDetails == SigningDetails.UNKNOWN) {
            pkg.mSigningDetails = verified;
        } else {
            if (!Signature.areExactMatch(pkg.mSigningDetails.signatures, verified.signatures)) {
                throw new PackageParserException(
                        INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES,
                        apkPath + " has mismatched certificates");
            }
        }
    }
```

注释2-1处，是 APK 的验签入口，接着来到该文件：
/frameworks/base/core/java/android/util/apk/ApkSignatureVerifier.java  
代码段3:
```
    /**
     * Verifies the provided APK and returns the certificates associated with each signer.
     *
     * @throws PackageParserException if the APK's signature failed to verify.
     */
    public static PackageParser.SigningDetails verify(String apkPath,
            @SignatureSchemeVersion int minSignatureSchemeVersion)
            throws PackageParserException {

        if (minSignatureSchemeVersion > SignatureSchemeVersion.SIGNING_BLOCK_V3) {
            // V3 and before are older than the requested minimum signing version
            throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,
                    "No signature found in package of version " + minSignatureSchemeVersion
            + " or newer for package " + apkPath);
        }

        // first try v3
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "verifyV3");
        try {
            ApkSignatureSchemeV3Verifier.VerifiedSigner vSigner =
                    ApkSignatureSchemeV3Verifier.verify(apkPath);
            Certificate[][] signerCerts = new Certificate[][] { vSigner.certs };
            Signature[] signerSigs = convertToSignatures(signerCerts);
            Signature[] pastSignerSigs = null;
            int[] pastSignerSigsFlags = null;
            if (vSigner.por != null) {
                // populate proof-of-rotation information
                pastSignerSigs = new Signature[vSigner.por.certs.size()];
                pastSignerSigsFlags = new int[vSigner.por.flagsList.size()];
                for (int i = 0; i < pastSignerSigs.length; i++) {
                    pastSignerSigs[i] = new Signature(vSigner.por.certs.get(i).getEncoded());
                    pastSignerSigsFlags[i] = vSigner.por.flagsList.get(i);
                }
            }
            return new PackageParser.SigningDetails(
                    signerSigs, SignatureSchemeVersion.SIGNING_BLOCK_V3,
                    pastSignerSigs, pastSignerSigsFlags);
        } 

        ......

        // try v2
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "verifyV2");
        try {
            // V2 验签的正式入口
            Certificate[][] signerCerts = ApkSignatureSchemeV2Verifier.verify(apkPath);
            Signature[] signerSigs = convertToSignatures(signerCerts);

            return new PackageParser.SigningDetails(
                    signerSigs, SignatureSchemeVersion.SIGNING_BLOCK_V2);
        } catch (SignatureNotFoundException e) {
            // not signed with v2, try older if allowed
            if (minSignatureSchemeVersion >= SignatureSchemeVersion.SIGNING_BLOCK_V2) {
                throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,
                        "No APK Signature Scheme v2 signature in package " + apkPath, e);
            }
        } catch (Exception e) {
            // APK Signature Scheme v2 signature found but did not verify
            throw new  PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,
                    "Failed to collect certificates from " + apkPath
                            + " using APK Signature Scheme v2", e);
        } finally {
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }

    ......

    }
```

到此找到了 V2 验签的函数入口： ApkSignatureSchemeV2Verifier.verify(apkPath);  
接着看源码，来到该文件：  
/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java  
代码段4:  
```
    /**
     * Verifies APK Signature Scheme v2 signatures of the provided APK and returns the certificates
     * associated with each signer.
     *
     * @throws SignatureNotFoundException if the APK is not signed using APK Signature Scheme v2.
     * @throws SecurityException if a APK Signature Scheme v2 signature of this APK does not verify.
     * @throws IOException if an I/O error occurs while reading the APK file.
     */
    public static X509Certificate[][] verify(String apkFile)
            throws SignatureNotFoundException, SecurityException, IOException {
        VerifiedSigner vSigner = verify(apkFile, true);
        return vSigner.certs;
    }


    private static VerifiedSigner verify(String apkFile, boolean verifyIntegrity)
            throws SignatureNotFoundException, SecurityException, IOException {
        try (RandomAccessFile apk = new RandomAccessFile(apkFile, "r")) {
            return verify(apk, verifyIntegrity);
        }
    }


    /**
     * Verifies APK Signature Scheme v2 signatures of the provided APK and returns the certificates
     * associated with each signer.
     *
     * @throws SignatureNotFoundException if the APK is not signed using APK Signature Scheme v2.
     * @throws SecurityException if an APK Signature Scheme v2 signature of this APK does not
     *         verify.
     * @throws IOException if an I/O error occurs while reading the APK file.
     */
    private static VerifiedSigner verify(RandomAccessFile apk, boolean verifyIntegrity)
            throws SignatureNotFoundException, SecurityException, IOException {
        // 4-1
        SignatureInfo signatureInfo = findSignature(apk);
        // 4-2
        return verify(apk, signatureInfo, verifyIntegrity);
    }
```

经过一系列的调用，我们来到了关键的一步，V2 验签的主流程。

# V2 验签的主流程
验签的过程主要分两步：  
第一，代码段4中的注释4-1，提取签名块；  
第二，代码段4中的注释4-2，验证签名块。

# V2 签名块的提取
接着代码段4中的注释4-1，执行了 findSignature 函数，来到该文件：  
/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java  
代码段5:  
```
    /**
     * Returns the APK Signature Scheme v2 block contained in the provided APK file and the
     * additional information relevant for verifying the block against the file.
     *
     * @throws SignatureNotFoundException if the APK is not signed using APK Signature Scheme v2.
     * @throws IOException if an I/O error occurs while reading the APK file.
     */
    private static SignatureInfo findSignature(RandomAccessFile apk)
            throws IOException, SignatureNotFoundException {
        return ApkSigningBlockUtils.findSignature(apk, APK_SIGNATURE_SCHEME_V2_BLOCK_ID);
    }
```

接着来到该文件：
/frameworks/base/core/java/android/util/apk/ApkSigningBlockUtils.java
代码段6:
```
    /**
     * Returns the APK Signature Scheme block contained in the provided APK file and the
     * additional information relevant for verifying the block against the file.
     *
     * @param blockId the ID value in the APK Signing Block's sequence of ID-value pairs
     *                identifying the appropriate block to find, e.g. the APK Signature Scheme v2
     *                block ID.
     *
     * @throws SignatureNotFoundException if the APK is not signed using this scheme.
     * @throws IOException if an I/O error occurs while reading the APK file.
     */
    static SignatureInfo findSignature(RandomAccessFile apk, int blockId)
            throws IOException, SignatureNotFoundException {
        // Find the ZIP End of Central Directory (EoCD) record.
        Pair<ByteBuffer, Long> eocdAndOffsetInFile = getEocd(apk);
        ByteBuffer eocd = eocdAndOffsetInFile.first;
        long eocdOffset = eocdAndOffsetInFile.second;
        if (ZipUtils.isZip64EndOfCentralDirectoryLocatorPresent(apk, eocdOffset)) {
            throw new SignatureNotFoundException("ZIP64 APK not supported");
        }

        // Find the APK Signing Block. The block immediately precedes the Central Directory.
        long centralDirOffset = getCentralDirOffset(eocd, eocdOffset);
        Pair<ByteBuffer, Long> apkSigningBlockAndOffsetInFile =
                findApkSigningBlock(apk, centralDirOffset);
        ByteBuffer apkSigningBlock = apkSigningBlockAndOffsetInFile.first;
        long apkSigningBlockOffset = apkSigningBlockAndOffsetInFile.second;

        // Find the APK Signature Scheme Block inside the APK Signing Block.
        ByteBuffer apkSignatureSchemeBlock = findApkSignatureSchemeBlock(apkSigningBlock,
                blockId);

        return new SignatureInfo(
                apkSignatureSchemeBlock,
                apkSigningBlockOffset,
                centralDirOffset,
                eocdOffset,
                eocd);
    }
```

先看到函数的末尾 return 了一个 SignatureInfo 实例，并入参了5个参数，可知前面的代码就是获取到这5个参数的。从名字可以看出，这5个参数分别表示：签名块、签名块偏移量、中央目录区偏移量、中央结尾区偏移量、中央结尾区，可知验签的时候需要用到这几个参数。  
其中的签名块，apkSignatureSchemeBlock，如下图所示的红色块：  
再次看到该官方的图片：
![](http://guoke24.top/img/apk-before-after-signing.png)<br>  
这一步的目的就是提取红色的签名块。  
具体怎么获取这几个参数的源码分析先省略了，其中主要就是 zip 文件格式的操作。  
下面简单讲一下原理：  
第一，根据 eocd 的标示ID 0x06054b50，找到 eocd 的字节数组。  
第二，再截取 eocd 的字节数组中的下标为16开始的四个字节，转换成 int 类型数据的值，该数值就是 centralDirOffset ，即中央目录区偏移量。  
第三，紧挨着中央目录区之前的是16个字节魔数，再往前的是8个字节的size，表示签名块字节数的大小。因第二部已经得知中央目录区偏移量，所以签名块的字节数组和其偏移量都可以找出来了。  
第四，一个带有原生 V2 签名和自定义 V2 格式签名的 APK 的例子：
```
50 4b 03 04 0a 00 00 08 // 内容区start
...
3c 04 00 00 2B 05 00 00 // 内容区end
81 0c 00 00 00 00 00 00 // apk签名分块长度前缀
D0 05 00 00 00 00 00 00 // v2签名分块的长度前缀
1a 87 09 71             // v2签名分块的ID
....
92 ea 35 02 03 01 00 01 // v2签名分块end
89 06 00 00 00 00 00 00 // 自定义签名分块长度前缀
78 67 64 32             // 自定义签名分块的ID
....
7c 04 66 63 7d c2 b3 25 // 自定义签名分块end
81 0c 00 00 00 00 00 00 // apk签名分块长度后缀
.. .. .. .. .. .. .. .. 42 6c 6f 63 6b 20 34 32//魔数
50 4b 01 02 09 00 09 00 // cd 中央区 start
........... 2e 52 53 41 // cd 中央区 end
50 4b 05 06 // eocd 中央尾区 开头的标示，大端序为 06 05 4b 50
...
0f da c3 00 // cd 中央区 偏移量
00 00 // eocd 中央尾区 end
```

到此提取签名块的分析告一段落。

# V2 签名块的验证
再回到代码段4中的注释4-2，  
/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java
```
    private static VerifiedSigner verify(RandomAccessFile apk, boolean verifyIntegrity)
            throws SignatureNotFoundException, SecurityException, IOException {
        // 4-1
        SignatureInfo signatureInfo = findSignature(apk);
        // 4-2
        return verify(apk, signatureInfo, verifyIntegrity);
    }
```
注释4-2处，执行的 verify 函数，去验证签名块信息。接着看代码：  
/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java  
代码段7:  
```
    /**
     * Verifies the contents of the provided APK file against the provided APK Signature Scheme v2
     * Block.
     *
     * @param signatureInfo APK Signature Scheme v2 Block and information relevant for verifying it
     *        against the APK file.
     */
    private static VerifiedSigner verify(
            RandomAccessFile apk,
            SignatureInfo signatureInfo,
            boolean doVerifyIntegrity) throws SecurityException, IOException {
        int signerCount = 0;
        Map<Integer, byte[]> contentDigests = new ArrayMap<>();
        List<X509Certificate[]> signerCerts = new ArrayList<>();
        CertificateFactory certFactory;
        try {
            certFactory = CertificateFactory.getInstance("X.509");
        } catch (CertificateException e) {
            throw new RuntimeException("Failed to obtain X.509 CertificateFactory", e);
        }
        ByteBuffer signers;
        try {
            signers = getLengthPrefixedSlice(signatureInfo.signatureBlock);
        } catch (IOException e) {
            throw new SecurityException("Failed to read list of signers", e);
        }
        while (signers.hasRemaining()) {
            signerCount++;
            try {
                ByteBuffer signer = getLengthPrefixedSlice(signers);
                X509Certificate[] certs = verifySigner(signer, contentDigests, certFactory);
                signerCerts.add(certs);
            } catch (IOException | BufferUnderflowException | SecurityException e) {
                throw new SecurityException(
                        "Failed to parse/verify signer #" + signerCount + " block",
                        e);
            }
        }

        if (signerCount < 1) {
            throw new SecurityException("No signers found");
        }

        if (contentDigests.isEmpty()) {
            throw new SecurityException("No content digests found");
        }

        if (doVerifyIntegrity) {
            ApkSigningBlockUtils.verifyIntegrity(contentDigests, apk, signatureInfo);
        }

        byte[] verityRootHash = null;
        if (contentDigests.containsKey(CONTENT_DIGEST_VERITY_CHUNKED_SHA256)) {
            byte[] verityDigest = contentDigests.get(CONTENT_DIGEST_VERITY_CHUNKED_SHA256);
            verityRootHash = ApkSigningBlockUtils.parseVerityDigestAndVerifySourceLength(
                    verityDigest, apk.length(), signatureInfo);
        }

        return new VerifiedSigner(
                signerCerts.toArray(new X509Certificate[signerCerts.size()][]),
                verityRootHash);
    }
```









