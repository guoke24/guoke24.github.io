---
layout:     post
title:      "View 工作原理的源头"
subtitle:   "read the fxxking source code"
date:       2020-02-01 12:00:00
author:     "GuoHao"
header-img: "img/waittouse.jpg"
catalog: true
tags:
    - Android
    - 源码
    - View 工作原理
    - View
---

# 前言
由该文章： [[Activity 的根视图 -- DecorView 的构成 ]] ，可知，
一个 Activity 持有 一个 PhoneWindow 类对象，
PhoneWindow 类对象内的 mDecor 变量，就是 Activity 的根视图 DecorView 实例。

前提知识交代完毕。
# 概览

当新建一个Activity 的时候，ActivityManagerService(简称 AMS) 会通过 Binder 机制，
跨进程通讯，调用到 ActivityThread#H#handleMessage --> ActivityThread 的 handleLaunchActivity 函数，然后执行 handleResumeActivity 函数。

- ActivityThread#handleLaunchActivity
Activity 内的 PhoneWindow 实例内的 DecorView 实例，创建完成<br>

- ActivityThread#handleResumeActivity
创建 ViewRootImpl 实例，DecorView 实例的引用传递给其内部的 mView 变量，然后执行 ViewRootImpl#requestLayout 函数，开始 View 的工作流程。

<br>
接着从 handleLaunchActivity 函数开始看。  

# handleLaunchActivity

- ActivityThread#handleLaunchActivity 
```
	WindowManagerGlobal.initialize();

        final Activity a = performLaunchActivity(r, customIntent);
```
<br>
- ActivityThread#performLaunchActivity
```
  if (r.isPersistable()) {
	mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
   } else {
	mInstrumentation.callActivityOnCreate(activity, r.state);
   }
```
<br>
- Instrumentation#callActivityOnCreate
```
        prePerformCreate(activity);
        activity.performCreate(icicle);
        postPerformCreate(activity);
```
<br>
- Activity#performCreate
```
	if (persistentState != null) {
            onCreate(icicle, persistentState);
        } else {
            onCreate(icicle);
        }
```
- Activity#onCreate

**小节一下**<br>
到此可知，ActivityThread#handleLaunchActivity 函数，会触发 Activity#onCreate 函数，
接着调用 setContent 函数，接下来的调用链可以参考 [[Activity 的根视图 -- DecorView]] ，结果就是：
Activity 内的 PhoneWindow 实例内的 DecorView 实例，在此时创建。
并通过 Activity#onCreate 内调用 setContentView 函数，构造以 DecorView 为根的视图树 ViewTree 。
在 Activity 中，可通过 getWindow().getDecorView() 来获得 DecorView 类实例。

##### 本小节调用链：
- ActivityThread#handleLaunchActivity
- ActivityThread#performLaunchActivity
- Instrumentation#callActivityOnCreate
- Activity#performCreate
- Activity#onCreate

<br>
DecorView 类实例创建完成后，就需要开始工作流程了。在哪里开始的呢？

当 ActivityThread 的 handleLaunchActivity 函数执行完之后，handleResumeActivity 也会被执行，该函数会导致视图树的工作流程的开始。
我们从 ActivityThread 的 handleResumeActivity 函数开始看。

# handleResumeActivity
- ActivityThread#handleResumeActivity
```
	View decor = r.window.getDecorView();
	// 略。。。
	ViewManager wm = a.getWindowManager();
	WindowManager.LayoutParams l = r.window.getAttributes();
	// 略。。。
	wm.addView(decor, l);
```
<br>
- WindowManagerImpl#addView
- WindowManagerGlobal#addView
```
	root = new ViewRootImpl(view.getContext(), display);
	// 略。。。
	try {
                root.setView(view, wparams, panelParentView);
        }
```
<br>
- ViewRootImpl#setView
```
public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {
      synchronized (this) {
	if (mView == null) {
	    mView = view;

	    mWindowAttributes.copyFrom(attrs);
	    // 略。。。
	    // Schedule the first layout -before- adding to the window
	    // manager, to make sure we do the relayout before receiving
	    // any other events from the system.
	    requestLayout();
```
- ViewRootImpl#requestLayout
```
	// 开始 View 的工作流程
```

**小节一下**<br>
到此可知，ActivityThread#handleResumeActivity 会调用到 ViewRootImpl#setView，
在此期间，创建 ViewRootImpl 实例，把创建好的 DecorView 实例，传递给 ViewRootImpl 实例，交给其内部的 mView 变量引用，然后执行 ViewRootImpl#requestLayout 函数，开始 View 的工作流程。

#####  本小节调用链：
- ActivityThread#handleResumeActivity
- WindowManagerImpl#addView
- WindowManagerGlobal#addView
- ViewRootImpl#setView
- ViewRootImpl#requestLayout

接着看 ViewRootImpl#requestLayout 函数。

### requestLayout
- ViewRootImpl#requestLayout
```
    @Override
    public void requestLayout() {
        if (!mHandlingLayoutInLayoutRequest) {
            checkThread();
            mLayoutRequested = true;
            scheduleTraversals();
        }
    }
```

- ViewRootImpl#scheduleTraversals
```
    void scheduleTraversals() {
        if (!mTraversalScheduled) {
            mTraversalScheduled = true;
            mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();
            mChoreographer.postCallback(
                    Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable/*接着这看*/, null);

	// ......
        }
    }
```

- ViewRootImpl#mTraversalRunnable
```
    final TraversalRunnable mTraversalRunnable = new TraversalRunnable();

    final class TraversalRunnable implements Runnable {
        @Override
        public void run() {
            doTraversal();
        }
    }
```

- ViewRootImpl#doTraversal
```
    void doTraversal() {
        if (mTraversalScheduled) {
            mTraversalScheduled = false;
            mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);

	   // 。。。

            performTraversals();// 此处触发三大流程 
	  
	   // 。。。
        }
    }
```
- ViewRootImpl#performTraversals
```
	boolean newSurface = false;
	WindowManager.LayoutParams lp = mWindowAttributes;
	Rect frame = mWinFrame;

	if (mWidth != frame.width() || mHeight != frame.height()) {
		mWidth = frame.width();
		mHeight = frame.height();
	}
	int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
	int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);

        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);

	// ---------------------- 分割线 ----------------------

        final boolean didLayout = layoutRequested && (!mStopped || mReportNextDraw);
        if (didLayout) {
            performLayout(lp, mWidth, mHeight);

	// ---------------------- 分割线 ----------------------

                if (!hadSurface) {
                    if (mSurface.isValid()) {
                        newSurface = true;

	// 略。。。
        if (!cancelDraw && !newSurface) {
            performDraw();

```

- ViewRootImpl#performMeasure
```
	mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);
```

- ViewRootImpl#performLayout
```
	final View host = mView;

	host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());

	mInLayout = false;
	int numViewsRequestingLayout = mLayoutRequesters.size();
	if (numViewsRequestingLayout > 0) {
		 // 。。。
	    ArrayList<View> validLayoutRequesters = getValidLayoutRequesters (mLayoutRequesters,false);

	     if (validLayoutRequesters != null) {
	       // 。。。
	       mInLayout = true;
	       host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight());
	       // 。。。
```

- ViewRootImpl#performDraw
- ViewRootImpl#draw
- ViewRootImpl#drawSoftware
```
	mView.draw(canvas);
```

**小节一下**<br>
requestLayout 函数，会触发 View 工作的三大流程。
performTraversals 函数，800行左右的代码，比较复杂，我们只需要知道其内部触发三大流程 performMeasure，performLayout，performDraw 即可。详细源码，[可参考] ( https://www.androidos.net.cn/android/8.0.0_r4/xref/frameworks/base/core/java/android/view/ViewRootImpl.java )。
<br>
##### 本小节调用链：
- ViewRootImpl#setView
- ViewRootImpl#requestLayout
- ViewRootImpl#scheduleTraversals
- mChoreographer.postCallback( ... , mTraversalRunnable , ...)
- ViewRootImpl#TraversalRunnable.run
- ViewRootImpl#doTraversal
- ViewRootImpl#performTraversals
- ViewRootImpl#performMeasure -> DecorView#measure
- ViewRootImpl#performLayout -> DecorView#layout
- ViewRootImpl#performDraw -> draw -> drawSoftware -> DecorView#draw

# 调用链汇总
- AMS#startActivityAsUser ......

- ActivityThread#H#handleMessage ......

- ActivityThread#handleLaunchActivity
  - ActivityThread#performLaunchActivity
  - Instrumentation#callActivityOnCreate
  - Activity#performCreate
  - Activity#onCreate
- ActivityThread#handleResumeActivity
  - WindowManagerImpl#addView
  - WindowManagerGlobal#addView
  - ViewRootImpl#setView
  - ViewRootImpl#requestLayout
  - ViewRootImpl#scheduleTraversals
  - mChoreographer.postCallback( ... , mTraversalRunnable , ...)
  - ViewRootImpl#TraversalRunnable.run
  - ViewRootImpl#doTraversal
  - ViewRootImpl#performTraversals
    - ViewRootImpl#performMeasure -> DecorView#measure
    - ViewRootImpl#performLayout -> DecorView#layout
    - ViewRootImpl#performDraw -> draw -> drawSoftware -> DecorView#draw

