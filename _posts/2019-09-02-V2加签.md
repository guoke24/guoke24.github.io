---
layout:     post
title:      "Android V2 签名-加签"
subtitle:   "源码角度"
date:       2019-09-02 12:00:00
author:     "GuoHao"
header-img: "img/waittouse.jpg"
catalog: true
tags:
    - Android
    - 源码
    - 签名
---

# 前言

之所以会研究这块内容，是因为前段时间接手的一个验签的项目，正是遵循了 Android V2 签名方案，于是就去研究了一部分 Android 原生的 V2 加签和验签的源码，现在趁着比较空闲，就把 Android 原生的 V2 加签和验签的源码梳理一番。本篇文章将研究 **加签** 这一块的源码。

# V2 签名方案的原理

首先，找到谷歌官方的文档，需要翻墙：<br>
[APK 签名方案 v2](https://source.android.com/security/apksigning/v2)<br>
辅助理解：<br>
[Android V2签名机制以及ApkSignerV2签名源码解析](https://www.jianshu.com/p/dc320629bf9d)<br>
[一篇文章看明白 Android v1 & v2 签名机制](https://blog.csdn.net/freekiteyu/article/details/84849651)<br>


v2 签名的整体流程概括：  
一个 APK 文件其实就是一个 ZIP 格式的文件，而一个 ZIP 格式的文件分为三部分：  
**内容去，中央目录区，结尾区**。  
**结尾区** 内记录了 **中央目录区** 在文件中的偏移量。<br>
所谓的 V2 签名方案，就是根据某种规则，产生签名块，再把签名块插入到 **内容区和中央目录区** 之间，<br>
然后再更新 **结尾区** 内的中央目录区的偏移量的值。<br>

借用官方的图，如下：  
![](http://guoke24.top/img/apk-before-after-signing.png)<br>

如图所示，红色那一块代表了 APK 签名块。<br>
用类json格式表示如下：  
```
apk
{
    beforeCentralDir,
    apkSigningBlock,// apk 签名分块
    centralDir,
    eocd,
}
```

接下来说一下 **签名块** 的内部结构。<br>
引用官方文档中描述 **签名块** 结构的一段话：
>格式  
“APK 签名分块”的格式如下（所有数字字段均采用小端字节序）：  
* size of block，以字节数（不含此字段）计 (uint64)  
* 带 uint64 长度前缀的“ID-值”对序列：  
  * ID (uint32)  
  * value（可变长度：“ID-值”对的长度 - 4 个字节）  
* size of block，以字节数计 - 与第一个字段相同 (uint64)  
* magic“APK 签名分块 42”（16 个字节）  

用类json格式表示如下：
```
apk
{
    beforeCentralDir,
    apkSigningBlock,// apk 签名分块
		{
		    blockSizeFieldValue,
		    pairSizeFieldValue,
		    APK_SIGNATURE_SCHEME_V2_BLOCK_ID,
		    apkSignatureSchemeV2Block，// value 值，内含 “ID-值”对，V2 分块
		    blockSizeFieldValue,
		    APK_SIGNING_BLOCK_MAGIC,
		}
    centralDir,
    eocd,
}
```
接下来说一下 **签名块 V2 分块** 的内部结构。<br>
引用官方文档中描述 **签名块 V2 分块** 结构的一段话：
>格式  
“APK 签名方案 v2 分块”存储在“APK 签名分块”内，ID 为 0x7109871a。<br>
“APK 签名方案 v2 分块”的格式如下（所有数字值均采用小端字节序，所有带长度前缀的字段均使用 uint32 值表示长度）：<br>
* 带长度前缀的 signer（带长度前缀）序列：<br>
  * 带长度前缀的 signed data：<br>
    * 带长度前缀的 digests（带长度前缀）序列：<br>
      * signature algorithm ID (uint32)<br>
      * （带长度前缀）digest - 请参阅受完整性保护的内容<br>
    * 带长度前缀的 X.509 certificates 序列：<br>
      * 带长度前缀的 X.509 certificate（ASN.1 DER 形式）<br>
    * 带长度前缀的 additional attributes（带长度前缀）序列：<br>
      * ID (uint32)<br>
      * value（可变长度：附加属性的长度 - 4 个字节）<br>
  * 带长度前缀的 signatures（带长度前缀）序列：<br>
      * signature algorithm ID (uint32)<br>
      * signed data 上带长度前缀的 signature<br>
  * 带长度前缀的 public key（SubjectPublicKeyInfo，ASN.1 DER 形式）<br>

**签名块 v2 分块** 用类json格式表示如下：
```
apkSignatureSchemeV2Block，// value 值，内含 “ID-值”对，V2 分块  
{
	len-signers[len-signer]
	{
		signer
		{
			len-signedData, //签名数据
			{
				len-digests["len-(签名算法ID-(len-摘要))"],  
				len-certificates["len-certificate"], //从第一个 certificate 内的公钥，对应签名的私钥
				len-additional_attributes["len-(ID-(len-attribute))"],  
			}
			len-signatures["len-(签名算法ID-(len-signature))"], //签名值 
			len-publicKey // 公钥，第一个 certificate 内取到的 
		}
}
```
其中，“len-”表示带长度前缀的意思，“signers[signer]”表示： signer 序列，所以，结合起来：  
“len-signers[signer]”表示：带长度前缀的 signer 序列；  
“len-signers[len-signer]”表示：带长度前缀的 signer（带长度前缀）序列；  
换句话说，signers[signer] 就是一个数组（也称序列），内部元素为 signer，接着给每个内部元素加上长度前缀，就有一个新的数组：  
signers[len-signer]，内部元素为 len-signer，如果再给该新的数组加一个长度前缀，就有：  
len-signers[len-signer]。  
**签名块 v2 分块**,本质上就是一个 **带长度前缀的序列（数组）**，  
其内部每个元素为 **带长度前缀的 signer**，即其内部每个元素为 **len-signer**。<br>
<br>
**补充说明：在上述的类json格式的代码中，“[]”表示一个序列（数组），内含n个同类型元素,“{}”表示一个结构体，内部的元素都只有一个。**<br>
<br>
* signer 的内部结构，包含个三元素：len-signedData，len-signatures，len-publicKey；<br>
  * 第一个元素 len-signedData ，签名数据，其内部结构比较复杂，我们慢慢将之拆分：  
    * signedData 内部的第一个元素，它的格式为 len-digests，即带长度前缀的摘要序列（数组），  
其内部含多个相同格式的元素 ["len-(签名算法ID-(len-摘要))"]，即带长度前缀的“ID-value”对，  
其 ID 是 签名算法ID，value 是 len-摘要，即带长度前缀的摘要，  
到这我们就可以简单理解为，digests 每个内部元素就是一个 “算法ID-摘要” 的映射对；  
为何是这种结构，后续源码分析的时候会讲到。  
    * signedData 内部的第二个元素，它的格式为 len-certificates，带长度前缀的证书序列（数组），
其内部含多个相同格式的元素 ["len-certificate"]，即带长度前缀的证书；  
    * signedData 内部的第三个元素，它的格式为 len-additional_attributes，即带长度前缀的附加数据序列（数组），  
其内部元素的结构跟 signedData 内部的第一个元素类似。而且 Android 原生的 V2 签名不带数附加据，后续源码会讲到。
  * 第二个元素 len-signatures，签名值序列，结构根 len-digests["len-(签名算法ID-(len-摘要))"] 类似；
  * 第三个元素 len-publicKey，带长度前缀的公钥，简单结构。


最终，APK 的总体结构可以表示如下：
```
apk
{
    beforeCentralDir,
    apkSigningBlock,// apk 签名分块
	{
		blockSizeFieldValue,
		pairSizeFieldValue,
		APK_SIGNATURE_SCHEME_V2_BLOCK_ID,
		apkSignatureSchemeV2Block，// value 值，内含 “ID-值”对，V2 分块
		{
			len-signers[len-signer]
			{
				signer
				{
					len-signedData,
					{
						len-digests["len-(签名算法ID-(len-摘要))"],
						len-certificates["len-certificate"],
						len-new byte[0],
					}
					len-signatures["len-(签名算法ID-(len-signature))"],
					len-publicKey
				}
			}
		}
		blockSizeFieldValue,
		APK_SIGNING_BLOCK_MAGIC,
	}
    centralDir,
    eocd,
}
```

到此，可以简单的说，V2 分块内，有多个 singer，而每个 signer 内又有多个摘要，多个证书和多个签名值。  
为什么是这样的结构呢？那就得看源码才能找到答案了。<br>

# V2 签名方案中加签的源码实现

源码在此链接可以看到：[V2加签源码](https://android.googlesource.com/platform/build/+/dd910c5/tools/signapk/src/com/android/signapk/ApkSignerV2.java)<br>


起始函数为 sign ；相关代码如下：  
代码段1:
```
    /**
     * Signs the provided APK using APK Signature Scheme v2 and returns the signed APK as a list of
     * consecutive chunks.
     *
     * ......
     *
     * @param inputApk contents of the APK to be signed. The APK starts at the current position
     *        of the buffer and ends at the limit of the buffer.
     * @param signerConfigs signer configurations, one for each signer.
     *
     * ......
     */
    public static ByteBuffer[] sign(
            ByteBuffer inputApk,
            List<SignerConfig> signerConfigs)
            throws ApkParseException, InvalidKeyException, SignatureException {

        ......

        // 1-1
        // Create ByteBuffers holding the contents of everything before ZIP Central Directory,
        // ZIP Central Directory, and ZIP End of Central Directory.
        inputApk.clear();
        ByteBuffer beforeCentralDir = getByteBuffer(inputApk, centralDirOffset);
        ByteBuffer centralDir = getByteBuffer(inputApk, eocdOffset - centralDirOffset);
        // Create a copy of End of Central Directory because we'll need modify its contents later.
        byte[] eocdBytes = new byte[inputApk.remaining()];
        inputApk.get(eocdBytes);
        ByteBuffer eocd = ByteBuffer.wrap(eocdBytes);
        eocd.order(inputApk.order());

        // 1-2
        // Figure which which digests to use for APK contents.
        Set<Integer> contentDigestAlgorithms = new HashSet<>();
        for (SignerConfig signerConfig : signerConfigs) {
            for (int signatureAlgorithm : signerConfig.signatureAlgorithms) {
                contentDigestAlgorithms.add(
                        getSignatureAlgorithmContentDigestAlgorithm(signatureAlgorithm));
            }
        }

        // 1-3
        // Compute digests of APK contents.
        Map<Integer, byte[]> contentDigests; // digest algorithm ID -> digest
        try {
            contentDigests =
                    computeContentDigests(
                            contentDigestAlgorithms,
                            new ByteBuffer[] {beforeCentralDir, centralDir, eocd});
        } catch (DigestException e) {
            throw new SignatureException("Failed to compute digests of APK", e);
        }

        // 1-4
        // Sign the digests and wrap the signatures and signer info into an APK Signing Block.
        ByteBuffer apkSigningBlock =
                ByteBuffer.wrap(generateApkSigningBlock(signerConfigs, contentDigests));

		......

		// 1-5
        // Insert APK Signing Block immediately before the ZIP Central Directory.
        return new ByteBuffer[] {
                beforeCentralDir,
                apkSigningBlock,
                centralDir,
                eocd,
        };
    }
```

首先看该函数的入参：  
```ByteBuffer inputApk``` 就是待签名apk的字节数组，被包装成了 ByteBuffer，目的是便于进行读取和复制等操作；  
```List<SignerConfig> signerConfigs``` 就是签名者配置信息集，这意味着签名者可能不止一个。  
接着看 SignerConfig 类的源码：
```
    /**
     * Signer configuration.
     */
    public static final class SignerConfig {
        /** Private key. */
        public PrivateKey privateKey;
        /**
         * Certificates, with the first certificate containing the public key corresponding to
         * {@link #privateKey}.
         */
        public List<X509Certificate> certificates;
        /**
         * List of signature algorithms with which to sign (see {@code SIGNATURE_...} constants).
         */
        public List<Integer> signatureAlgorithms;
    }
```  
可知，每个 **签名者配置信息** 包括：私钥，证书序列，签名算法ID的序列。<br>

接着看，  
注释1-1处，从入参的 inputApk 提取出了三部分：beforeCentralDir、centralDir、eocd，都是 ByteBuffer 类型。  

注释1-2处，通过两次遍历，把入参的 signerConfigs 的所有的签名算法，通过函数 getSignatureAlgorithmContentDigestAlgorithm 转换成对应的摘要算法，添加到集合 contentDigestAlgorithms 去了。  
函数 getSignatureAlgorithmContentDigestAlgorithm 的源码如下：
```
    private static int getSignatureAlgorithmContentDigestAlgorithm(int sigAlgorithm) {
        switch (sigAlgorithm) {
            case SIGNATURE_RSA_PSS_WITH_SHA256:
            case SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA256:
            case SIGNATURE_ECDSA_WITH_SHA256:
            case SIGNATURE_DSA_WITH_SHA256:
                return CONTENT_DIGEST_CHUNKED_SHA256;
            case SIGNATURE_RSA_PSS_WITH_SHA512:
            case SIGNATURE_RSA_PKCS1_V1_5_WITH_SHA512:
            case SIGNATURE_ECDSA_WITH_SHA512:
            case SIGNATURE_DSA_WITH_SHA512:
                return CONTENT_DIGEST_CHUNKED_SHA512;
            default:
                throw new IllegalArgumentException(
                        "Unknown signature algorithm: 0x"
                                + Long.toHexString(sigAlgorithm & 0xffffffff));
        }
    }
```
由此可知，签名算法有8种，摘要算法只有两种：SHA256 和 SHA512。  

注释1-3，计算并构造 "摘要算法ID - 分块摘要序列的摘要" 的 映射对，存储到变量 contentDigests 中。  

注释1-4，构造 apk 签名分块。  

注释1-5，构造并返回带 V2 签名的 APK。  
到此，对一个 APK 加上 V2 签名的流程就走完了。其中注释1-3和注释1-4中的代码逻辑才是核心，将在下面展开讲解。<br>