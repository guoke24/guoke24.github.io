---
layout:     post
title:      "Android V2 签名-加签"
subtitle:   "源码角度"
date:       2019-09-02 12:00:00
author:     "GuoHao"
header-img: "img/waittouse.jpg"
catalog: true
tags:
    - Android
    - 源码
    - 签名
---

# 前言

之所以会研究这块内容，是因为前段时间接手的一个验签的项目，正是遵循了 Android V2 签名方案，于是就去研究了一部分 Android 原生的 V2 加签和验签的源码，现在趁着比较空闲，就把 Android 原生的 V2 加签和验签的源码梳理一番。本篇文章将研究 **加签** 这一块的源码。

# V2 签名方案的原理

首先，找到谷歌官方的文档，需要翻墙：<br>
[APK 签名方案 v2](https://source.android.com/security/apksigning/v2)<br>
辅助理解：<br>
[Android V2签名机制以及ApkSignerV2签名源码解析](https://www.jianshu.com/p/dc320629bf9d)<br>
[一篇文章看明白 Android v1 & v2 签名机制](https://blog.csdn.net/freekiteyu/article/details/84849651)<br>


v2 签名的整体流程概括：  
一个 APK 文件其实就是一个 ZIP 格式的文件，而一个 ZIP 格式的文件分为三部分：  
**内容去，中央目录区，结尾区**。  
**结尾区** 内记录了 **中央目录区** 在文件中的偏移量。<br>
所谓的 V2 签名方案，就是根据某种规则，产生签名块，再把签名块插入到 **内容区和中央目录区** 之间，<br>
然后再更新 **结尾区** 内的中央目录区的偏移量的值。<br>

借用官方的图，如下：  
![](http://guoke24.top/img/apk-before-after-signing.png)<br>
![](http://127.0.0.1:4000/img/apk-before-after-signing.png)<br>

如图所示，红色那一块代表了 APK 签名块。<br>
用类json格式表示如下：  
```
apk
{
    beforeCentralDir,
    apkSigningBlock,// apk 签名分块
    centralDir,
    eocd,
}
```

接下来说一下 **签名块** 的内部结构。<br>
引用官方文档中描述 **签名块** 结构的一段话：
>格式  
“APK 签名分块”的格式如下（所有数字字段均采用小端字节序）：  
* size of block，以字节数（不含此字段）计 (uint64)  
* 带 uint64 长度前缀的“ID-值”对序列：  
  * ID (uint32)  
  * value（可变长度：“ID-值”对的长度 - 4 个字节）  
* size of block，以字节数计 - 与第一个字段相同 (uint64)  
* magic“APK 签名分块 42”（16 个字节）  

用类json格式表示如下：
```
apk
{
    beforeCentralDir,
    apkSigningBlock,// apk 签名分块
		{
		    blockSizeFieldValue,
		    pairSizeFieldValue,
		    APK_SIGNATURE_SCHEME_V2_BLOCK_ID,
		    apkSignatureSchemeV2Block，// value 值，内含 “ID-值”对，V2 分块
		    blockSizeFieldValue,
		    APK_SIGNING_BLOCK_MAGIC,
		}
    centralDir,
    eocd,
}
```
接下来说一下 **签名块 V2 分块** 的内部结构。<br>
引用官方文档中描述 **签名块 V2 分块** 结构的一段话：
>格式  
“APK 签名方案 v2 分块”存储在“APK 签名分块”内，ID 为 0x7109871a。<br>
“APK 签名方案 v2 分块”的格式如下（所有数字值均采用小端字节序，所有带长度前缀的字段均使用 uint32 值表示长度）：<br>
* 带长度前缀的 signer（带长度前缀）序列：<br>
  * 带长度前缀的 signed data：<br>
    * 带长度前缀的 digests（带长度前缀）序列：<br>
      * signature algorithm ID (uint32)<br>
      * （带长度前缀）digest - 请参阅受完整性保护的内容<br>
    * 带长度前缀的 X.509 certificates 序列：<br>
      * 带长度前缀的 X.509 certificate（ASN.1 DER 形式）<br>
    * 带长度前缀的 additional attributes（带长度前缀）序列：<br>
      * ID (uint32)<br>
      * value（可变长度：附加属性的长度 - 4 个字节）<br>
  * 带长度前缀的 signatures（带长度前缀）序列：<br>
      * signature algorithm ID (uint32)<br>
      * signed data 上带长度前缀的 signature<br>
  * 带长度前缀的 public key（SubjectPublicKeyInfo，ASN.1 DER 形式）<br>

**签名块 v2 分块** 用类json格式表示如下：
```
apkSignatureSchemeV2Block，// value 值，内含 “ID-值”对，V2 分块  
{
	len-signers[len-signer]
	{
		signer
		{
			len-signedData, //签名数据
			{
				len-digests["len-(签名算法ID-(len-摘要))"],  
				len-certificates["len-certificate"], //从第一个 certificate 内的公钥，对应签名的私钥
				len-additional_attributes["len-(ID-(len-attribute))"],  
			}
			len-signatures["len-(签名算法ID-(len-signature))"], //签名值 
			len-publicKey // 公钥，第一个 certificate 内取到的 
		}
}
```
其中，“len-”表示带长度前缀的意思，“signers[signer]”表示： signer 序列，所以，结合起来：  
“len-signers[signer]”表示：带长度前缀的 signer 序列；  
“len-signers[len-signer]”表示：带长度前缀的 signer（带长度前缀）序列；  
换句话说，signers[signer] 就是一个数组（也称序列），内部元素为 signer，接着给每个内部元素加上长度前缀，就有一个新的数组：  
signers[len-signer]，内部元素为 len-signer，如果再给该新的数组加一个长度前缀，就有：  
len-signers[len-signer]。  
**签名块 v2 分块**,本质上就是一个 **带长度前缀的序列（数组）**，  
其内部每个元素为 **带长度前缀的 signer**，即其内部每个元素为 **len-signer**。<br>
<br>
**补充说明：在上述的类json格式的代码中，“[]”表示一个序列（数组），内含n个同类型元素,“{}”表示一个结构体，内部的元素都只有一个。**<br>
<br>
* signer 的内部结构，包含个三元素：len-signedData，len-signatures，len-publicKey；<br>
  * 第一个元素 len-signedData ，签名数据，其内部结构比较复杂，我们慢慢将之拆分：  
    * signedData 内部的第一个元素，它的格式为 len-digests，即带长度前缀的摘要序列（数组），  
其内部含多个相同格式的元素 ["len-(签名算法ID-(len-摘要))"]，即带长度前缀的“ID-value”对，  
其 ID 是 签名算法ID，value 是 len-摘要，即带长度前缀的摘要，  
到这我们就可以简单理解为，digests 每个内部元素就是一个 “算法ID-摘要” 的映射对；  
为何是这种结构，后续源码分析的时候会讲到。  
    * signedData 内部的第二个元素，它的格式为 len-certificates，带长度前缀的证书序列（数组），
其内部含多个相同格式的元素 ["len-certificate"]，即带长度前缀的证书；  
    * signedData 内部的第三个元素，它的格式为 len-additional_attributes，即带长度前缀的附加数据序列（数组），  
其内部元素的结构跟 signedData 内部的第一个元素类似。而且 Android 原生的 V2 签名不带数附加据，后续源码会讲到。
  * 第二个元素 len-signatures，签名值序列，结构根 len-digests["len-(签名算法ID-(len-摘要))"] 类似；
  * 第三个元素 len-publicKey，带长度前缀的公钥，简单结构。


最总，APK 的总体结构可以表示如下：
```
apk
{
    beforeCentralDir,
    apkSigningBlock,// apk 签名分块
	{
		blockSizeFieldValue,
		pairSizeFieldValue,
		APK_SIGNATURE_SCHEME_V2_BLOCK_ID,
		apkSignatureSchemeV2Block，// value 值，内含 “ID-值”对，V2 分块
		{
			len-signers[len-signer]
			{
				signer
				{
					len-signedData,
					{
						len-digests["len-(签名算法ID-(len-摘要))"],
						len-certificates["len-certificate"],
						len-new byte[0],
					}
					len-signatures["len-(签名算法ID-(len-signature))"],
					len-publicKey
				}
			}
		}
		blockSizeFieldValue,
		APK_SIGNING_BLOCK_MAGIC,
	}
    centralDir,
    eocd,
}
```

# V2 签名方案的源码实现
