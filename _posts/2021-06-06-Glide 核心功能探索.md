---
layout:     post  
title:      "Glide 核心功能探索"  
subtitle:   "再微观深入细节"  
date:       2021-06-06 12:00:00  
author:     "GuoHao"  
header-img: "img/guitar.jpg"  
catalog: true  
tags:  
    - Android  
    - 源码  
    - 三方库

---

## 前言

在总结了 Glide 的 into 函数的调用链后，接可以看看一些核心功能的关键函数都做了啥。

RequestBuilder.into -> ... —> SingleRequest.begin，
//该调用链省了中间很多步骤。

然后调用 `target.getSize(this); ` 获取 targetView 的 size，这是一个关键节点。

跟着调用链走，来到这个关键节点：

## 获取控件的尺寸

ViewTarget$SizeDeterminer.getSize

```
// ViewTarget 的内部类 SizeDeterminer

    void getSize(@NonNull SizeReadyCallback cb) {
      int currentWidth = getTargetWidth();
      int currentHeight = getTargetHeight();
      if (isViewStateAndSizeValid(currentWidth, currentHeight)) {
        cb.onSizeReady(currentWidth, currentHeight);
        return;
      }

    private int getTargetHeight() {
      int verticalPadding = view.getPaddingTop() + view.getPaddingBottom();
      LayoutParams layoutParams = view.getLayoutParams();
      int layoutParamSize = layoutParams != null ? layoutParams.height : PENDING_SIZE;
      return getTargetDimen(view.getHeight(), layoutParamSize, verticalPadding);
    }
    
    // 根据：自身size、布局参数、内边距，三个参数来算
    private int getTargetDimen(int viewSize, int paramSize, int paddingSize) {
      // We consider the View state as valid if the View has non-null layout params and a non-zero
      // layout params width and height. This is imperfect. We're making an assumption that View
      // parents will obey their child's layout parameters, which isn't always the case.
      int adjustedParamSize = paramSize - paddingSize;
      if (adjustedParamSize > 0) {
        return adjustedParamSize;
      }

      // Since we always prefer layout parameters with fixed sizes, even if waitForLayout is true,
      // we might as well ignore it and just return the layout parameters above if we have them.
      // Otherwise we should wait for a layout pass before checking the View's dimensions.
      if (waitForLayout && view.isLayoutRequested()) {
        return PENDING_SIZE;
      }

      // We also consider the View state valid if the View has a non-zero width and height. This
      // means that the View has gone through at least one layout pass. It does not mean the Views
      // width and height are from the current layout pass. For example, if a View is re-used in
      // RecyclerView or ListView, this width/height may be from an old position. In some cases
      // the dimensions of the View at the old position may be different than the dimensions of the
      // View in the new position because the LayoutManager/ViewParent can arbitrarily decide to
      // change them. Nevertheless, in most cases this should be a reasonable choice.
      int adjustedViewSize = viewSize - paddingSize;
      if (adjustedViewSize > 0) {
        return adjustedViewSize;
      }

      // Finally we consider the view valid if the layout parameter size is set to wrap_content.
      // It's difficult for Glide to figure out what to do here. Although Target.SIZE_ORIGINAL is a
      // coherent choice, it's extremely dangerous because original images may be much too large to
      // fit in memory or so large that only a couple can fit in memory, causing OOMs. If users want
      // the original image, they can always use .override(Target.SIZE_ORIGINAL). Since wrap_content
      // may never resolve to a real size unless we load something, we aim for a square whose length
      // is the largest screen size. That way we're loading something and that something has some
      // hope of being downsampled to a size that the device can support. We also log a warning that
      // tries to explain what Glide is doing and why some alternatives are preferable.
      // Since WRAP_CONTENT is sometimes used as a default layout parameter, we always wait for
      // layout to complete before using this fallback parameter (ConstraintLayout among others).
      if (!view.isLayoutRequested() && paramSize == LayoutParams.WRAP_CONTENT) {
        if (Log.isLoggable(TAG, Log.INFO)) {
          Log.i(
              TAG,
              "Glide treats LayoutParams.WRAP_CONTENT as a request for an image the size of this"
                  + " device's screen dimensions. If you want to load the original image and are"
                  + " ok with the corresponding memory cost and OOMs (depending on the input size),"
                  + " use override(Target.SIZE_ORIGINAL). Otherwise, use LayoutParams.MATCH_PARENT,"
                  + " set layout_width and layout_height to fixed dimension, or use .override()"
                  + " with fixed dimensions.");
        }
        return getMaxDisplayLength(view.getContext());
      }

      // If the layout parameters are < padding, the view size is < padding, or the layout
      // parameters are set to match_parent or wrap_content and no layout has occurred, we should
      // wait for layout and repeat.
      return PENDING_SIZE;
    }
```

这里是获取 targetView 的 size 的代码摘要，
从其自身size、布局参数、内边距，三个参数来算，
是值得学习的代码。

继续跟着调用链走，在拿到 targetView 的 size 之后，就可以回调到
SingleRequest.onSizeReady 方法。

SingleRequest.onSizeReady 方法，启动引擎，
思路是首先尝试查询内存是否有缓存，
策略是根据 key 查询图片缓存，
key 由 targetView 的 size（宽和高）、scaleType 等信息构建出来的。
然后先后调用两个关键节点函数：

## 加载活跃资源的缓存 

Engine.loadFromActiveResources(key);

```
  @Nullable
  private EngineResource<?> loadFromActiveResources(Key key) {
    EngineResource<?> active = activeResources.get(key);
    if (active != null) {
      active.acquire();
    }

    return active;
  }
```

## 加载 Lru 的缓存 

Engine.loadFromCache(key);

```
  private EngineResource<?> loadFromCache(Key key) {
    EngineResource<?> cached = getEngineResourceFromCache(key);
    if (cached != null) {
      cached.acquire();
      activeResources.activate(key, cached);
    }
    return cached;
  }
```

若找不到，则去做网络请求。

## 网络请求

关键的函数：

```
SourceGenerator # startNext() // 发起

HttpUrlFetcher # loadData(...) // 真正的网络请求

SourceGenerator # onDataReadyInternal(...) // 回调
```

首先明确网络请求是在 SourceGenerator 中发起和回调的。
具体的网络请求是由 HttpUrlFetcher 来做的。
网络回调后，就从 SourceGenerator.onDataReadyInternal 方法开始。

## 网络请求后

### 压缩与解码

关键函数：Downsampler # decodeFromWrappedStreams

SourceGenerator 对象中发生网络请求和回调，然后再调用
DecodeJob # onDataFetcherReady 方法，告知数据已经准备好。

DecodeJob 类的作用介绍，根据其源码注释，为：
> 用于对「从缓存或数据源中获取的」数据进行「解码」和「变换」等操作。
> decoding -「解码」，
> transformation -「变换」，
> transcodes -「编码转换」；

从 DecodeJob # onDataFetcherReady 方法开始，一连串的调用，最终会从解码器集合里找出合适的、对应的解码器去解码数据。

以 url 为 http 为例，这个合适的解码器就是 ByteBufferBitmapDecoder。

接着看 ByteBufferBitmapDecoder # decode

```
// ByteBufferBitmapDecoder.java

  @Override
  public Resource<Bitmap> decode(
      @NonNull ByteBuffer source, int width, int height, @NonNull Options options)
      throws IOException {
    // 1，用工具拿到输入流
    InputStream is = ByteBufferUtil.toStream(source);
    // 2，交给手下处理
    return downsampler.decode(is, width, height, options);
  }
```

可知拿到输入流，交给 Downsampler # decode 处理：

```
// Downsampler.java

  public Resource<Bitmap> decode(InputStream is, int outWidth, int outHeight, Options options)
      throws IOException {
    return decode(is, outWidth, outHeight, options, EMPTY_CALLBACKS);
  }
  
  public Resource<Bitmap> decode(
      InputStream is,
      int requestedWidth,
      int requestedHeight,
      Options options,
      DecodeCallbacks callbacks)
      throws IOException {
    return decode(
        new ImageReader.InputStreamImageReader(is, parsers, byteArrayPool),
        requestedWidth,
        requestedHeight,
        options,
        callbacks);
  }

  private Resource<Bitmap> decode(
      ImageReader imageReader,
      int requestedWidth,
      int requestedHeight,
      Options options,
      DecodeCallbacks callbacks)
      throws IOException {
    byte[] bytesForOptions = byteArrayPool.get(ArrayPool.STANDARD_BUFFER_SIZE_BYTES, byte[].class);
    BitmapFactory.Options bitmapFactoryOptions = getDefaultOptions();
    bitmapFactoryOptions.inTempStorage = bytesForOptions;

    DecodeFormat decodeFormat = options.get(DECODE_FORMAT);
    PreferredColorSpace preferredColorSpace = options.get(PREFERRED_COLOR_SPACE);
    DownsampleStrategy downsampleStrategy = options.get(DownsampleStrategy.OPTION);
    boolean fixBitmapToRequestedDimensions = options.get(FIX_BITMAP_SIZE_TO_REQUESTED_DIMENSIONS);
    boolean isHardwareConfigAllowed =
        options.get(ALLOW_HARDWARE_CONFIG) != null && options.get(ALLOW_HARDWARE_CONFIG);

    try {
      Bitmap result =
          decodeFromWrappedStreams(
              imageReader,
              bitmapFactoryOptions,
              downsampleStrategy,
              decodeFormat,
              preferredColorSpace,
              isHardwareConfigAllowed,
              requestedWidth,
              requestedHeight,
              fixBitmapToRequestedDimensions,
              callbacks);
      return BitmapResource.obtain(result, bitmapPool);
    } finally {
      releaseOptions(bitmapFactoryOptions);
      byteArrayPool.put(bytesForOptions);
    }
  }
```

经过三个函数调用，走到了 **核心函数**：

#### Downsampler # decodeFromWrappedStreams


```
// Downsampler.java

  private Bitmap decodeFromWrappedStreams(
      ImageReader imageReader,
      BitmapFactory.Options options,
      DownsampleStrategy downsampleStrategy,
      DecodeFormat decodeFormat,
      PreferredColorSpace preferredColorSpace,
      boolean isHardwareConfigAllowed,
      int requestedWidth,
      int requestedHeight,
      boolean fixBitmapToRequestedDimensions,
      DecodeCallbacks callbacks)
      throws IOException {
    long startTime = LogTime.getLogTime();

    int[] sourceDimensions = getDimensions(imageReader, options, callbacks, bitmapPool);
    int sourceWidth = sourceDimensions[0];
    int sourceHeight = sourceDimensions[1];
    String sourceMimeType = options.outMimeType;

    // If we failed to obtain the image dimensions, we may end up with an incorrectly sized Bitmap,
    // so we want to use a mutable Bitmap type. One way this can happen is if the image header is so
    // large (10mb+) that our attempt to use inJustDecodeBounds fails and we're forced to decode the
    // full size image.
    if (sourceWidth == -1 || sourceHeight == -1) {
      isHardwareConfigAllowed = false;
    }

    // 先判断是否旋转，若选择了 90 度，宽高互换
    int orientation = imageReader.getImageOrientation();
    int degreesToRotate = TransformationUtils.getExifOrientationDegrees(orientation);
    boolean isExifOrientationRequired = TransformationUtils.isExifOrientationRequired(orientation);

    int targetWidth =
        requestedWidth == Target.SIZE_ORIGINAL
            ? (isRotationRequired(degreesToRotate) ? sourceHeight : sourceWidth)
            : requestedWidth;
    int targetHeight =
        requestedHeight == Target.SIZE_ORIGINAL
            ? (isRotationRequired(degreesToRotate) ? sourceWidth : sourceHeight)
            : requestedHeight;

    ImageType imageType = imageReader.getImageType();

    // 计算放缩，结果记入 options
    calculateScaling(
        imageType,
        imageReader,
        callbacks,
        bitmapPool,
        downsampleStrategy,
        degreesToRotate,
        sourceWidth,
        sourceHeight,
        targetWidth,
        targetHeight,
        options);
    
    // 计算配置，结果记入 options
    calculateConfig(
        imageReader,
        decodeFormat,
        isHardwareConfigAllowed,
        isExifOrientationRequired,
        options,
        targetWidth,
        targetHeight);

    // === 适配版本特性 start ===
    // Android 4.4 及以上？
    boolean isKitKatOrGreater = Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
    
    // Prior to KitKat, the inBitmap size must exactly match the size of the bitmap we're decoding.
    // 在 4.4 之前，inBitmap 的 size 必须跟正在解码的 bitmap 的 size 一样，才能使用
    if ((options.inSampleSize == 1 || isKitKatOrGreater) && shouldUsePool(imageType)) {
      int expectedWidth;
      int expectedHeight;
      if (sourceWidth >= 0
          && sourceHeight >= 0
          && fixBitmapToRequestedDimensions
          && isKitKatOrGreater) {
        expectedWidth = targetWidth;
        expectedHeight = targetHeight;
      } else {
        float densityMultiplier =
            isScaling(options) ? (float) options.inTargetDensity / options.inDensity : 1f;
        int sampleSize = options.inSampleSize;
        int downsampledWidth = (int) Math.ceil(sourceWidth / (float) sampleSize);
        int downsampledHeight = (int) Math.ceil(sourceHeight / (float) sampleSize);
        expectedWidth = Math.round(downsampledWidth * densityMultiplier);
        expectedHeight = Math.round(downsampledHeight * densityMultiplier);

        ...
      }
      // If this isn't an image, or BitmapFactory was unable to parse the size, width and height
      // will be -1 here.
      if (expectedWidth > 0 && expectedHeight > 0) {
        setInBitmap(options, bitmapPool, expectedWidth, expectedHeight);
      }
    }

    // 颜色模式的适配，即 ARGB_8888 这类的属性。
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.P) {
      boolean isP3Eligible =
          preferredColorSpace == PreferredColorSpace.DISPLAY_P3
              && options.outColorSpace != null
              && options.outColorSpace.isWideGamut();
      options.inPreferredColorSpace =
          ColorSpace.get(isP3Eligible ? ColorSpace.Named.DISPLAY_P3 : ColorSpace.Named.SRGB);
    } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
      options.inPreferredColorSpace = ColorSpace.get(ColorSpace.Named.SRGB);
    }
    // === 适配版本特性 end ===
    
    // options 就绪，开始解码
    Bitmap downsampled = decodeStream(imageReader, options, callbacks, bitmapPool);
    
    ...

    Bitmap rotated = null;
    if (downsampled != null) {
      // If we scaled, the Bitmap density will be our inTargetDensity. Here we correct it back to
      // the expected density dpi.
      // 如果我们做过放缩，那 Bitmap 的 density 将是我们的 inTargetDensity。
      // 在这里我们修正它为期望的 density dpi
      downsampled.setDensity(displayMetrics.densityDpi);

      // 旋转或翻转以 match 给定的方向 orientation
      rotated = TransformationUtils.rotateImageExif(bitmapPool, downsampled, orientation);
      if (!downsampled.equals(rotated)) {
        // 放入池中，此处是为了弃用 bitmap 的内存复用
        bitmapPool.put(downsampled); 
      }
    }

    return rotated;
  }
```

配合注释看下来，基本清楚 decodeFromWrappedStreams 方法的工作：
- 处理：旋转、放缩 和 配置 等属性优化
    - 放缩相关属性：options.inSampleSize、options.inScaled、options.inTargetDensity、options.inDensity
    - 配置相关属性：Option.inPreferredConfig、Option.inDither
- 兼容不容版本的 Option.inBitmap 使用逻辑（复用弃用的 Bitmap 内存）
- 兼容不容版本的 Option.inPreferredColorSpace 配置
- 把 bitmap 存到 bitmapPool 已备下次的弃用内存复用。

#### 放缩的计算

```
  private static void calculateScaling(
      ImageType imageType,
      ImageReader imageReader,
      DecodeCallbacks decodeCallbacks,
      BitmapPool bitmapPool,
      DownsampleStrategy downsampleStrategy,
      int degreesToRotate,
      int sourceWidth,
      int sourceHeight,
      int targetWidth,
      int targetHeight,
      BitmapFactory.Options options)
      throws IOException {
    // We can't downsample source content if we can't determine its dimensions.
    if (sourceWidth <= 0 || sourceHeight <= 0) {
      ...
      return;
    }

    int orientedSourceWidth = sourceWidth;
    int orientedSourceHeight = sourceHeight;
    // If we're rotating the image +-90 degrees, we need to downsample accordingly so the image
    // width is decreased to near our target's height and the image height is decreased to near
    // our target width.
    //noinspection SuspiciousNameCombination
    // 旋转了就宽高互换
    if (isRotationRequired(degreesToRotate)) {
      orientedSourceWidth = sourceHeight;
      orientedSourceHeight = sourceWidth;
    }

    final float exactScaleFactor =
        downsampleStrategy.getScaleFactor(
            orientedSourceWidth, orientedSourceHeight, targetWidth, targetHeight);

    if (exactScaleFactor <= 0f) {
      throw new IllegalArgumentException(
          ...
    }

    SampleSizeRounding rounding =
        downsampleStrategy.getSampleSizeRounding(
            orientedSourceWidth, orientedSourceHeight, targetWidth, targetHeight);
    if (rounding == null) {
      throw new IllegalArgumentException("Cannot round with null rounding");
    }

    int outWidth = round(exactScaleFactor * orientedSourceWidth);
    int outHeight = round(exactScaleFactor * orientedSourceHeight);

    int widthScaleFactor = orientedSourceWidth / outWidth;
    int heightScaleFactor = orientedSourceHeight / outHeight;

    // TODO: This isn't really right for both CenterOutside and CenterInside. Consider allowing
    // DownsampleStrategy to pick, or trying to do something more sophisticated like picking the
    // scale factor that leads to an exact match.
    int scaleFactor =
        rounding == SampleSizeRounding.MEMORY
            ? Math.max(widthScaleFactor, heightScaleFactor)
            : Math.min(widthScaleFactor, heightScaleFactor);

    int powerOfTwoSampleSize;
    // BitmapFactory does not support downsampling wbmp files on platforms <= M. See b/27305903.
    if (Build.VERSION.SDK_INT <= 23
        && NO_DOWNSAMPLE_PRE_N_MIME_TYPES.contains(options.outMimeType)) {
      powerOfTwoSampleSize = 1;
    } else {
      powerOfTwoSampleSize = Math.max(1, Integer.highestOneBit(scaleFactor));
      if (rounding == SampleSizeRounding.MEMORY
          && powerOfTwoSampleSize < (1.f / exactScaleFactor)) {
        powerOfTwoSampleSize = powerOfTwoSampleSize << 1;
      }
    }

    // Here we mimic framework logic for determining how inSampleSize division is rounded on various
    // versions of Android. The logic here has been tested on emulators for Android versions 15-26.
    // PNG - Always uses floor
    // JPEG - Always uses ceiling
    // Webp - Prior to N, always uses floor. At and after N, always uses round.
    
    // 不同格式，不同 Android 版本，放缩因子计算规则也不一样
    options.inSampleSize = powerOfTwoSampleSize;
    
    int powerOfTwoWidth;
    int powerOfTwoHeight;
    if (imageType == ImageType.JPEG) {
      // libjpegturbo can downsample up to a sample size of 8. libjpegturbo uses ceiling to round.
      // After libjpegturbo's native rounding, skia does a secondary scale using floor
      // (integer division). Here we replicate that logic.
      int nativeScaling = Math.min(powerOfTwoSampleSize, 8);
      powerOfTwoWidth = (int) Math.ceil(orientedSourceWidth / (float) nativeScaling);
      powerOfTwoHeight = (int) Math.ceil(orientedSourceHeight / (float) nativeScaling);
      int secondaryScaling = powerOfTwoSampleSize / 8;
      if (secondaryScaling > 0) {
        powerOfTwoWidth = powerOfTwoWidth / secondaryScaling;
        powerOfTwoHeight = powerOfTwoHeight / secondaryScaling;
      }
    } else if (imageType == ImageType.PNG || imageType == ImageType.PNG_A) {
      powerOfTwoWidth = (int) Math.floor(orientedSourceWidth / (float) powerOfTwoSampleSize);
      powerOfTwoHeight = (int) Math.floor(orientedSourceHeight / (float) powerOfTwoSampleSize);
    } else if (imageType == ImageType.WEBP || imageType == ImageType.WEBP_A) {
      if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
        powerOfTwoWidth = Math.round(orientedSourceWidth / (float) powerOfTwoSampleSize);
        powerOfTwoHeight = Math.round(orientedSourceHeight / (float) powerOfTwoSampleSize);
      } else {
        powerOfTwoWidth = (int) Math.floor(orientedSourceWidth / (float) powerOfTwoSampleSize);
        powerOfTwoHeight = (int) Math.floor(orientedSourceHeight / (float) powerOfTwoSampleSize);
      }
    } else if (orientedSourceWidth % powerOfTwoSampleSize != 0
        || orientedSourceHeight % powerOfTwoSampleSize != 0) {
      // If we're not confident the image is in one of our types, fall back to checking the
      // dimensions again. inJustDecodeBounds decodes do obey inSampleSize.
      int[] dimensions = getDimensions(imageReader, options, decodeCallbacks, bitmapPool);
      // Power of two downsampling in BitmapFactory uses a variety of random factors to determine
      // rounding that we can't reliably replicate for all image formats. Use ceiling here to make
      // sure that we at least provide a Bitmap that's large enough to fit the content we're going
      // to load.
      powerOfTwoWidth = dimensions[0];
      powerOfTwoHeight = dimensions[1];
    } else {
      powerOfTwoWidth = orientedSourceWidth / powerOfTwoSampleSize;
      powerOfTwoHeight = orientedSourceHeight / powerOfTwoSampleSize;
    }

    double adjustedScaleFactor =
        downsampleStrategy.getScaleFactor(
            powerOfTwoWidth, powerOfTwoHeight, targetWidth, targetHeight);

    // Density scaling is only supported if inBitmap is null prior to KitKat. Avoid setting
    // densities here so we calculate the final Bitmap size correctly.
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
      options.inTargetDensity = adjustTargetDensityForError(adjustedScaleFactor);
      options.inDensity = getDensityMultiplier(adjustedScaleFactor);
    }
    if (isScaling(options)) {
      options.inScaled = true;
    } else {
      options.inDensity = options.inTargetDensity = 0;
    }
    ...
  }
```

代码略多，逻辑不复杂。主要是按顺序计算如下几个值：
* options.inSampleSize
* options.inScaled
* options.inTargetDensity
* options.inDensity


参考：[图片内存缓存处理](mweblib://16215749258614)，处理的思路是大同小异的。

#### 颜色规格的计算

```
  private void calculateConfig(
      ImageReader imageReader,
      DecodeFormat format,
      boolean isHardwareConfigAllowed,
      boolean isExifOrientationRequired,
      BitmapFactory.Options optionsWithScaling,
      int targetWidth,
      int targetHeight) {

    if (hardwareConfigState.setHardwareConfigIfAllowed(
        targetWidth,
        targetHeight,
        optionsWithScaling,
        isHardwareConfigAllowed,
        isExifOrientationRequired)) {
      return;
    }

    // Changing configs can cause skewing on 4.1, see issue #128.
    if (format == DecodeFormat.PREFER_ARGB_8888
        || Build.VERSION.SDK_INT == Build.VERSION_CODES.JELLY_BEAN) {
      optionsWithScaling.inPreferredConfig = Bitmap.Config.ARGB_8888;
      return;
    }

    boolean hasAlpha = false;
    try {
      hasAlpha = imageReader.getImageType().hasAlpha();
    } ...

    // 根据透明度做优化
    optionsWithScaling.inPreferredConfig =
        hasAlpha ? Bitmap.Config.ARGB_8888 : Bitmap.Config.RGB_565;
    
    // 抖动解码优化
    if (optionsWithScaling.inPreferredConfig == Config.RGB_565) {
      optionsWithScaling.inDither = true;
    }
  }
```

主要是计算 options 的 inPreferredConfig 的值，
默认是 Bitmap.Config.ARGB_8888，如果没有透明度，则是 Bitmap.Config.RGB_565。
Bitmap.Config.RGB_565 的格式则采用抖动解码。
options 的 inDither 属性，即抖动解码选项。

抖动解码，解决什么问题？
> 如果一张颜色很丰富的图，用一个位数比较低的颜色模式来解码的话，那么一个直观的感觉就是颜色不够用，那么这张图解出来之后，在一些颜色渐变的区域上就会有一些很明显的断裂色带，这个很好解释，因为一些丰富的颜色在位数较低的颜色模式下并没有，那么只能用相近的填充，可能一大片都没有，那么一大片都用这一个颜色填充，就形成了断裂色带。

> 如果采用抖动解码，那么就会在这些色带上采用随机噪声色来填充，目的是让这张图显示效果更好，色带不那么明显。
> ————————————————
> 版权声明：本文为CSDN博主「神仙的师父」
> 原文链接：https://blog.csdn.net/haozipi/article/details/47185535

#### 真解码的函数的小亮点

```
// Downsampler.java

  private static Bitmap decodeStream(
      ImageReader imageReader,
      BitmapFactory.Options options,
      DecodeCallbacks callbacks,
      BitmapPool bitmapPool)
      throws IOException {

    final Bitmap result;
    TransformationUtils.getBitmapDrawableLock().lock();
    try {
      result = imageReader.decodeBitmap(options);
    } catch (IllegalArgumentException e) {
      ...      
      if (options.inBitmap != null) {
        try {
          bitmapPool.put(options.inBitmap);
          // 1，尝试不用 inBitmap 再试一次 
          options.inBitmap = null;
          return decodeStream(imageReader, options, callbacks, bitmapPool);
        } ...
      }
      throw bitmapAssertionException;
    } ...

    return result;
  }
```

解码的逻辑很常规，不过有个值的学习的亮点：
注释1处，在使用 inBitmap 解码失败的情况下 尝试不用 inBitmap 再试一次解码。

### 解码后的工作

调用链回顾：
网络请求回调，从 DecodeJob # onDataFetcherReady 方法开始，
然后在 DecodeJob # decodeFromRetrievedData 方法中，

* 开启解码，并拿到带有 Bitmap 对象的 resource 对象，
解码过程经过很多调用，找到解码器，经过压缩规格等配置参数的计算，解码出一个 bitmap 对象；

* 然后，bitmap 对象包到 resource 对象中，

* 再之后，只剩两件事可做：
    - 缓存 resource！
    - 更新 UI！

所以，缓存的开始，也是在该函数：

#### DecodeJob # decodeFromRetrievedData

```
  private void decodeFromRetrievedData() {
    ...
    Resource<R> resource = null;
    try {
      // 1，解码出来的 Bitmap 对象，就包在 resource 对象
      resource = decodeFromData(currentFetcher, currentData, currentDataSource);
    } ...
    
    if (resource != null) {
      // 2，解码得到实例，就会去发通知
      notifyEncodeAndRelease(resource, currentDataSource, isLoadingFromAlternateCacheKey);
    } else {
      runGenerators();
    }
  }
```

从注释2的 notifyEncodeAndRelease 方法开始调用，会调用到 EngineJob 类对象的 onResourceReady 方法。

从 EngineJob 类的注释看其作用：

```
/**
 * A class that manages a load by adding and removing callbacks for for the load and notifying
 * callbacks when the load completes.
 */
// 翻译：
// 通过添加和移除回调，来管理每一次加载（load），当通一次加载（load）完成时通知回调。
class EngineJob<R> implements DecodeJob.Callback<R>, Poolable
```

接着看其 onResourceReady 方法源码：

#### EngineJob # onResourceReady

```
// EngineJob.java

  @Override
  public void onResourceReady(
      Resource<R> resource, DataSource dataSource, boolean isLoadedFromAlternateCacheKey) {
    synchronized (this) {
      this.resource = resource;
      this.dataSource = dataSource;
      this.isLoadedFromAlternateCacheKey = isLoadedFromAlternateCacheKey;
    }
    notifyCallbacksOfResult();
  }

  void notifyCallbacksOfResult() {
   ...

    // 1，缓存处理
    engineJobListener.onEngineJobComplete(this, localKey, localResource);

    // 2，线程切换更新 UI
    for (final ResourceCallbackAndExecutor entry : copy) {
      entry.executor.execute(new CallResourceReady(entry.cb));
    }
    ...
  }
```

在注释1，会走 缓存处理 的逻辑。
在注释2，会走 线程切换更新 UI。

#### 缓存处理

接着上段代码的注释1:

```
engineJobListener.onEngineJobComplete(this, localKey, localResource);
```

engineJobListener 就是 Engine 类对象。

##### Engine # onEngineJobComplete

```
// Engine.java

  @Override
  public synchronized void onEngineJobComplete(
      EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
    // A null resource indicates that the load failed, usually due to an exception.
    if (resource != null && resource.isMemoryCacheable()) {
      activeResources.activate(key, resource);
    }

    jobs.removeIfCurrent(key, engineJob);
  }
```

活跃资源是 ActiveResources 类：

```
private final ActiveResources activeResources;
```

ActiveResources 的关键源码：

##### ActiveResources 类三函数

```
final class ActiveResources {

  ...
  // 活跃资源就是包类一层弱引用的 HashMap
  @VisibleForTesting final Map<Key, ResourceWeakReference> activeEngineResources = new HashMap<>();
  private final ReferenceQueue<EngineResource<?>> resourceReferenceQueue = new ReferenceQueue<>();
  
  ...
  
  // 把图片保存时调用
  synchronized void activate(Key key, EngineResource<?> resource) {
    // resource 对象内包含 Bitmap 对象
    // 把 resource 再包一层弱引用 
    ResourceWeakReference toPut =
        new ResourceWeakReference(
            key, resource, resourceReferenceQueue, isActiveResourceRetentionAllowed);
    
    // 把 resource 放入集合
    ResourceWeakReference removed = activeEngineResources.put(key, toPut);
    if (removed != null) {
      removed.reset();
    }
  }
  
  ...
  
  // 查找图片时调用
  @Nullable
  synchronized EngineResource<?> get(Key key) {
    ResourceWeakReference activeRef = activeEngineResources.get(key);
    if (activeRef == null) {
      return null;
    }

    EngineResource<?> active = activeRef.get();
    if (active == null) {
      cleanupActiveReference(activeRef);
    }
    return active;
  }
  
  ...
  
  // 从此处移除图片时调用
  synchronized void deactivate(Key key) {
    // 从 hashmap 中移除
    ResourceWeakReference removed = activeEngineResources.remove(key);
    if (removed != null) {
      // 软引用 reset，就是把引用图片的字段赋值为空，"resource = null;"
      removed.reset();
    }
  }
```

由此可知：
活跃资源，即正在使用的资源图片，使用弱引用保存。
这样的目的，我猜测一下：
所谓正在使用的资源，就是被某个控件引用的资源。
如果该控件所在的界面意外被回收了，导致该控件也被回收，并来不及挪到 Lru 缓存，
则此时引用该图片的只有弱引用，而弱引用刚好是不影响垃圾回收的，
如果此处的弱引用换成强引用，则就会造成内存泄漏。
**总而言之就一句话，弱引用就是为了避免内存泄漏。**

接下来的问题：
如果用户释放了图片，那 Glide 是如何感知的呢？又是如何挪到 Lru 缓存的呢？
答案从 ActiveResources 的构造函数中看起：

##### 监控引用队列

```
// ActiveResources.java

  ActiveResources(boolean isActiveResourceRetentionAllowed) {
    // 同名构造函数
    this(
        isActiveResourceRetentionAllowed,
        // 创建单线程线程池
        java.util.concurrent.Executors.newSingleThreadExecutor(
            new ThreadFactory() {
              @Override
              public Thread newThread(@NonNull final Runnable r) {
                return new Thread(
                    new Runnable() {
                      @Override
                      public void run() {
                        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
                        r.run();
                      }
                    },
                    "glide-active-resources");
              }
            }));
  }

  // 再看上述构造函数会调用的同名构造函数
  @VisibleForTesting
  ActiveResources(
      boolean isActiveResourceRetentionAllowed, Executor monitorClearedResourcesExecutor) {
    this.isActiveResourceRetentionAllowed = isActiveResourceRetentionAllowed;
    // 就是上面创建的单线程线程池
    this.monitorClearedResourcesExecutor = monitorClearedResourcesExecutor;

    // 立马执行一个任务
    monitorClearedResourcesExecutor.execute(
        new Runnable() {
          @Override
          public void run() {
            cleanReferenceQueue();
          }
        });
  }
```

由此可知，在 ActiveResources 给创建的时候，其构造函数就会启动一个线程池，并执行一个任务。
该任务就是 cleanReferenceQueue() 方法。

##### ActiveResources # cleanReferenceQueue

```
// ActiveResources.java

  @Synthetic
  void cleanReferenceQueue() {
    // 只有没 Shutdown 就循环
    while (!isShutdown) {
      try {
        // 被回收的弱引用才会进入队列
        // 该函数的注释：Removes the next reference object in this queue, blocking until one becomes available.
        // 意思是函数是阻塞的，直到有元素进来才会被唤醒。
        ResourceWeakReference ref = (ResourceWeakReference) resourceReferenceQueue.remove();
        
        // 进一步处理
        cleanupActiveReference(ref);

        ...
      } ...
    }
  }
  
// 进一步调用
  @Synthetic
  void cleanupActiveReference(@NonNull ResourceWeakReference ref) {
    synchronized (this) {
      activeEngineResources.remove(ref.key);

      // ref.resource 就是那个内含 Bitmap 对象的 resource 对象
      if (!ref.isCacheable || ref.resource == null) {
        return;
      }
    }
    // 若 Bitmap 还没被回收，包一层 EngineResource 对象，
    EngineResource<?> newResource =
        new EngineResource<>(
            ref.resource, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ false, ref.key, listener);
    // 再把 EngineResource 对象，回调出去
    listener.onResourceReleased(ref.key, newResource);
  }
```

##### 弱引用的猜想与求证

> 弱引用被回收，进入了引用队列，但弱引用所引用的对象，还不一定被回收，即还有机会取回来。
> 猜想：弱引用 引用着 Bitmap，弱引用本身可能会比 Bitmap 更早被回收。然后 Bitmap 就会变成没有任何人引用它的情况，然后才会被回收。

如果弱引用被回收，而 Bitmap 还没被回收，则可知，Bitmap
被释放了，接着就会想办法通知给别人。

在看代码最后，listener 是 Engine 类。

##### Engine # onResourceReleased

```
// Engine.java

  @Override
  public void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
    // 1，从活跃资源中移除，源码可往上找
    activeResources.deactivate(cacheKey);
    if (resource.isMemoryCacheable()) {
      // 2，保存到 Lru，cache 对象就是 Lru
      cache.put(cacheKey, resource);
    } else {
      // 不支持内存 Lru 缓存，回收该资源
      resourceRecycler.recycle(resource, /*forceNextFrame=*/ false);
      // 源码追一追，发现是 "bitmapPool.put(bitmap);"
      // bitmapPool 就是那个 “复用废弃Bitmap内存” 的池中
    }
  }
```

由此可知：
得知有资源不在活跃，onResourceReleased 方法，做的事情很简单：
一是从活跃资源中移除；
二是尝试保存到 cache 缓存；
若不支持缓存，则进行回收，本质就是放入 bitmapPool，“复用废弃Bitmap内存” 的池。

接下来的问题，cache 字段的本体是什么？

稍微翻一翻前面的文章，从 cache 缓存查找图片的方法，是 Engine 的 loadFromCache 方法。

##### Engine # loadFromCache

```
// Engine.java

  private EngineResource<?> loadFromCache(Key key) {
    // 从 cache 查找
    EngineResource<?> cached = getEngineResourceFromCache(key);
    if (cached != null) {
      cached.acquire();
      // 找到，挪到活跃资源中存储
      activeResources.activate(key, cached);
    }
    return cached;
  }

  // 从 cache 查找的方法
  private EngineResource<?> getEngineResourceFromCache(Key key) {
    Resource<?> cached = cache.remove(key);

    final EngineResource<?> result;
    if (cached == null) {
      result = null;
    } else if (cached instanceof EngineResource) {
      // Save an object allocation if we've cached an EngineResource (the typical case).
      result = (EngineResource<?>) cached;
    } else {
      result =
          new EngineResource<>(
              cached, /*isMemoryCacheable=*/ true, /*isRecyclable=*/ true, key, /*listener=*/ this);
    }
    return result;
  }
```

从 cache 查找图片的逻辑很简单。
接着关键的问题是，cache 是什么类型？

```
private final MemoryCache cache;
```

MemoryCache 是接口，其实现类是 LruCache.java。

##### LruCache 类

```
// LruCache.java

/**
 * A general purpose size limited cache that evicts items using an LRU algorithm. By default every
 * item is assumed to have a size of one. Subclasses can override {@link #getSize(Object)}} to
 * change the size on a per item basis.
 *
 * @param <T> The type of the keys.
 * @param <Y> The type of the values.
 */
public class LruCache<T, Y> {
  // 最后一个参数为 true，表示按照 accessOrder，即访问顺序来访问。
  private final Map<T, Entry<Y>> cache = new LinkedHashMap<>(100, 0.75f, true);
  
  ...

  /**
   * Returns the item in the cache for the given key or null if no such item exists.
   *
   * @param key The key to check.
   */
  @Nullable
  public synchronized Y get(@NonNull T key) {
    Entry<Y> entry = cache.get(key);
    return entry != null ? entry.value : null;
  }

  /**
   * Adds the given item to the cache with the given key and returns any previous entry for the
   * given key that may have already been in the cache.
   *
   * <p>If the size of the item is larger than the total cache size, the item will not be added to
   * the cache and instead {@link #onItemEvicted(Object, Object)} will be called synchronously with
   * the given key and item.
   *
   * <p>The size of the item is determined by the {@link #getSize(Object)} method. To avoid errors
   * where {@link #getSize(Object)} returns different values for the same object when called at
   * different times, the size value is acquired in {@code put} and retained until the item is
   * evicted, replaced or removed.
   *
   * <p>If {@code item} is null the behavior here is a little odd. For the most part it's similar to
   * simply calling {@link #remove(Object)} with the given key. The difference is that calling this
   * method with a null {@code item} will result in an entry remaining in the cache with a null
   * value and 0 size. The only real consequence is that at some point {@link #onItemEvicted(Object,
   * Object)} may be called with the given {@code key} and a null value. Ideally we'd make calling
   * this method with a null {@code item} identical to {@link #remove(Object)} but we're preserving
   * this odd behavior to match older versions :(.
   *
   * @param key The key to add the item at.
   * @param item The item to add.
   */
  @Nullable
  public synchronized Y put(@NonNull T key, @Nullable Y item) {
    final int itemSize = getSize(item);
    if (itemSize >= maxSize) {
      onItemEvicted(key, item);
      return null;
    }

    if (item != null) {
      currentSize += itemSize;
    }
    @Nullable Entry<Y> old = cache.put(key, item == null ? null : new Entry<>(item, itemSize));
    if (old != null) {
      currentSize -= old.size;

      if (!old.value.equals(item)) {
        onItemEvicted(key, old.value);
      }
    }
    evict();

    return old != null ? old.value : null;
  }

  /**
   * Removes the item at the given key and returns the removed item if present, and null otherwise.
   *
   * @param key The key to remove the item at.
   */
  @Nullable
  public synchronized Y remove(@NonNull T key) {
    Entry<Y> entry = cache.remove(key);
    if (entry == null) {
      return null;
    }
    currentSize -= entry.size;
    return entry.value;
  }
```

这是一个很标准的 LruCache 实现，其内部依赖的数据结构是 LinkedHashMap。
LinkedHashMap 的 accessOrder 字段为 true 时，按最近最少使用原则来维护内部的双向队列。
参考本地文章：[LinkedHashMap](mweblib://16142331230676)

还有个问题，被 Lru 缓存淘汰的图片取哪里了呢？
答：会进入 BitmapPool，以便内存复用。
同时，上述标题 Engine # onResourceReleased 中提到，如果资源被释放，没有开启内存缓存，也会放入 BitmapPool 中。

##### BitmapPool 类

有两个实现类，LruBitmapPool、BitmapPoolAdapter。判断逻辑如下：

```
// com/bumptech/glide/GlideBuilder.java

  @NonNull
  Glide build(@NonNull Context context) {
    ...
    if (bitmapPool == null) {
      // 1，内存size计算器
      int size = memorySizeCalculator.getBitmapPoolSize();
      if (size > 0) {
        bitmapPool = new LruBitmapPool(size);
      } else {
        bitmapPool = new BitmapPoolAdapter();
      }
    }
    ...
}
```

在注释 1 处的 内存 size 计算器 memorySizeCalculator 的 getBitmapPoolSize() 方法，得到内存 size。如果内存 size 大于 0，就使用 LruBitmapPool。
根据这个逻辑，可以猜测 BitmapPoolAdapter 是使用磁盘缓存的，LruBitmapPool 则是内存缓存。

###### LruBitmapPool

LruBitmapPool 内部使用 SizeConfigStrategy 类存储 bitmap，SizeConfigStrategy 类内部使用 GroupedLinkedMap 类作为数据结构，根据此注释，可知是一种类似 LinkedHashMap 的数据结构，也说明 LruBitmapPool 是使用内存缓存的。

###### BitmapPoolAdapter

BitmapPoolAdapter 的默认实现，put 方法直接回收 Bitmap，get 方法返回 null。也就是说是直接拒绝保存 Bitmap。它的真正目的是留给子类重新实现，也就是就给外部使用者拓展一个自定义逻辑的 Adapter 来处理 Bitmap 的保存。

##### 小结

缓存处理到此跟踪完毕。
缓存处理的工作内容总结：

网络请求拿到数据并解码得到资源后，先缓存到「**活跃资源**」对象中；
「**活跃资源**」对象内部是用 hashmap<Key, ResourceWeakReference> 来存储正在使用的图片，本质上就是用弱引用来保存正在使用的资源，使用弱引用时因为其不会阻碍垃圾回收。

活跃资源实例在构建时，会创建一个线程池并启动一个任务，该任务循环执行，从引用队列中取出弱引用，并把引用的资源挪到 cache 缓存中。又因为「从引用队列中取元素」的操作是阻塞的（新元素入队会唤醒），所以不会浪费性能。「while 循环 + 阻塞的从引用队列中取元素」这个模式，就能实时监控活跃的资源被释放，从而及时的挪到 cache 缓存。

cache 缓存的实现是 Lrucache 类，内部是依赖 LinkedHashMap 作为存储结构，符合最近最少使用的原则。

#### 线程切换更新 UI

在 EngineJob # onResourceReady 代码中，有这一段：

```
    entry.executor.execute(new CallResourceReady(entry.cb));
```

##### executor 的来源

省了追踪，直接看结果：

```
// RequestBuilder.java

  public <Y extends Target<TranscodeType>> Y into(@NonNull Y target) {
    return into(target, /*targetListener=*/ null, Executors.mainThreadExecutor());
  }
```

可知是切换到主线程执行 CallResourceReady 对象这个任务。

接着看 CallResourceReady 类对象的这个任务的执行过程。
这一段代码比较简单，不做详细分析。

##### CallResourceReady 类

```
// EngineJob.java 的内部类

  private class CallResourceReady implements Runnable {

    private final ResourceCallback cb;

    CallResourceReady(ResourceCallback cb) {
      this.cb = cb;
    }

    @Override
    public void run() {
      // Make sure we always acquire the request lock, then the EngineJob lock to avoid deadlock
      // (b/136032534).
      synchronized (cb.getLock()) {
        synchronized (EngineJob.this) {
          if (cbs.contains(cb)) {
            // Acquire for this particular callback.
            engineResource.acquire();
            // 跟这里
            callCallbackOnResourceReady(cb);
            removeCallback(cb);
          }
          decrementPendingCallbacks();
        }
      }
    }
  }
```

实现了 Runnable 接口，在线程池中执行 run 方法，然后调用 callCallbackOnResourceReady(cb) 方法。

```
// EngineJob.java 

  void callCallbackOnResourceReady(ResourceCallback cb) {
    try {
      // This is overly broad, some Glide code is actually called here, but it's much
      // simpler to encapsulate here than to do so at the actual call point in the
      // Request implementation.
      // 跟这里
      cb.onResourceReady(engineResource, dataSource, isLoadedFromAlternateCacheKey);
    } catch (Throwable t) {
      throw new CallbackException(t);
    }
  }
```

cb 是 SingleRequest.java

##### SingleRequest # onResourceReady

```
// SingleRequest.java

target.onResourceReady(result, animation);
// target 是 ImageViewTarget.java
```

##### ImageViewTarget # onResourceReady

```
// ImageViewTarget.java

  @Override
  public void onResourceReady(@NonNull Z resource, @Nullable Transition<? super Z> transition) {
    if (transition == null || !transition.transition(resource, this)) {
      setResourceInternal(resource);
    } else {
      maybeUpdateAnimatable(resource);
    }
  }
  
  private void setResourceInternal(@Nullable Z resource) {
    // Order matters here. Set the resource first to make sure that the Drawable has a valid and
    // non-null Callback before starting it.
    setResource(resource);
    maybeUpdateAnimatable(resource);
  }
```

##### BitmapImageViewTarget # setResource

```  
// BitmapImageViewTarget.java（ImageViewTarget.java 的子类）

  @Override
  protected void setResource(Bitmap resource) {
    view.setImageBitmap(resource);
  }
```


##### 小结

线程切换再更新 UI，最终是调用了 View 的 setImageBitmap 方法，把 bitmap 设置到要显示的控件上。而这一操作是在主线程中执行的。

## 总结

本片文章，主要探索来 Glide 框架，在请求到网络数据后的一些列操作。包括：解码（压缩比例，图片颜色模式、抖动解码、内存复用），缓存（活跃资源弱引用、释放资源 Lru、淘汰资源 BitmapPool）、切线程更新 UI，这三大块内容。

### 工作模型图

以请求网络数据，显示到一个 ImageView 的案例为准：

![屏幕快照 2021-06-14 下午5.01.16](/img/media/16234173036195/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202021-06-14%20%E4%B8%8B%E5%8D%885.01.16.png)

