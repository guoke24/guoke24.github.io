---
layout:     post
title:      "Handler 的工作原理"
subtitle:   ""
date:       2020-01-29 12:00:00
author:     "GuoHao"
header-img: "img/waittouse.jpg"
catalog: true
tags:
    - Android
    - 源码
    - Handler
---

# 总览
Handler 的工作流程
- 创建，绑定线程特有的 Looper 实例
- 发消息 Handler#sendMessage 或 Handler#post
- 入队 MessageQueue#enqueueMessage()
- 消息循环  Looper.loop() 
- 分发处理  Handler#dispatchMessage


# Handler 的用法示例

创建，定义处理逻辑：
```
	// 创建的时候，需要实现 handleMessage 函数
	Handler mHandler = new Handler(){
		@Override
		public void handleMessage(Message msg) {
			// do something                        
		}
	};
```

发消息：
```
	// 发送一个消息
	Message message = new Message();
	message.obj = "I am a message";
	mHandler.sendMessage(message);

	// post 一个线程
	mHandler.post(new Runnable() {
		@Override
		public void run() {
			 LogUtil.e("当前线程：" + Thread.currentThread().getName());
		}
	});
```



# 消息发送的两种方式 sendMessage 和 post

```
// 代码段0:
// Handler 类

    public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }

    public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis < 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + " sendMessageAtTime() called with no mQueue");
            Log.w("Looper", e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }
```
到此可知，最终调用了 enqueueMessage 函数进行入队处理。


再看 post 函数源码：

```
// 代码段0.1:
// Handler 类 

   public final boolean post(Runnable r)
    {
       return  sendMessageDelayed(getPostMessage(r), 0);
    }

    private static Message getPostMessage(Runnable r) {
        Message m = Message.obtain();
        m.callback = r;
        return m;
    }

    public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool; // 从线程池里取一个 Message 实例
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
```
post 函数提交的 Runnable 实例，会被放入 Message 实例的成员变量 callback 中，接着调用 
sendMessageDelayed 函数继续流程，以 Message 实例的形式继续传递。<br>

到此可知，无论调用 sendMessage 函数还是 post 函数，最终都会调用 sendMessageDelayed 函数，进而调用 enqueueMessage 函数把消息 msg 入队。


# 消息入队 MessageQueue#enqueueMessage() 

```
// 代码段1:
// Handler 类

    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this; //入队前，记录所属的 handler
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
```

```
// 代码段2:
// MessageQueue 类

    boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException("Message must have a target.");
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + " This message is already in use.");
        }

        synchronized (this) {
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + " sending message to a Handler on a dead thread");
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages; // 拿到表头
            boolean needWake;
            if (p == null || when == 0 || when < p.when) {
		// 如果表头为空 or 延迟时间为0 or 延迟时间比表头时间少
		// 则插入表头

                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
		// 否则插入中间

                // Inserted within the middle of the queue.  Usually we don't have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked && p.target == null && msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p; 
                    p = p.next; // 从表头往后遍历
                    if (p == null || when < p.when) { // 按 when 的早晚排序，若when相等，后入队的排后面，例如，2，3，5；入队是 3，那么循环到 p.when == 5 的时候break；
                        break;
                    }
                    if (needWake && p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg; // 完成插入
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
```
可知 queue 中，message 以链表的形式存储，按执行事件的早晚，即 when 由小到大排序，若when相等，后入队的排后面。

# 消息循环 Looper.loop() 
在文章  [[Handler 如何绑定 Thread 线程 ]] 中，可知 new Handler 之前，当前线程会通过委托 Looper.prapare() ，new 一个 Looper 实例并存到当前线程的线程本地 map （即 当前线程实例的成员变量 threadLocals）中，从而实现绑定当前线程 。<br>

Looper.prapare() 之后，执行 new Handler()，然后再执行 Looper.loop() 开启消息循环，不断从队列里取消息。否则刚刚 new 的 Handler 收不到消息。 <br>

去看 Looper.loop() 函数源码：

```
// 代码段3:
// Looper 类

    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        final MessageQueue queue = me.mQueue;

	// 。。。 略

        for (;;) {
            // 3-0 处，取出消息
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

	    //。。。

            final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
            final long dispatchEnd;
            try {
		// 3-1 分发给所属的 Handler 实例，参考代码段1
                msg.target.dispatchMessage(msg);
                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
            } finally {
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }

	    // 。。。

            msg.recycleUnchecked();
        }
    }
```
3-0 处，取出消息，并做一些判断，没问题就继续。
3-1处，msg.target 得到的是 msg 所属的 Handler 实例， 代码段1的 Handler 类的 enqueueMessage 函数把消息入队之前，赋值自身 this 给 msg.target 。
所以，msg.target.dispatchMessage(msg) 调用的是 Handler 类的 dispatchMessage 函数。
接着看 dispatchMessage 源码：

# 消息处理 Handler#dispatchMessage 

```
// 代码段4
// Handler 类

    public void dispatchMessage(Message msg) {
        if (msg.callback != null) { 
	     // 4-1 表示由 post 函数发送的 Runnable，参考代码段0.1，post 函数的源码可知
            handleCallback(msg);
        } else {
            if (mCallback != null) { 
                if (mCallback.handleMessage(msg)) { // 4-2 如果有回调处理了，直接返回
                    return;
                }
            }
            handleMessage(msg); //4-3 最后才叫给 handleMessage 函数
        }
    }

    private static void handleCallback(Message message) {
        message.callback.run();
    }
```
值得注意的是 4-2 处，mCallback  是在构造函数传进来的。

构造函数 和 Callback 的定义：
```
// 代码段4.1
// Handler 类

    public Handler(Callback callback) {
        this(callback, false);
    }

    public Handler(Callback callback, boolean async) {
	// 。。。

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread " + Thread.currentThread()
                        + " that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

    public interface Callback {
        /**
         * @param msg A {@link android.os.Message Message} object
         * @return True if no further handling is desired
         */
        public boolean handleMessage(Message msg);
    }
```
代码段4中，如果 mCallback.HandleMessage 返回 true，就表示处理了，就不会走 4-3 处的 handleMessage 函数。

# 总结
Handler 的工作流程<br>
- 创建，绑定线程特有的 Looper 实例
  - 构造函数内，mLooper = Looper.myLooper()
    - Looper 类的静态函数会 new 一个 Looper 实例，存到当前线程中
- 发消息 Handler#sendMessage 或 Handler#post
  - post 的 Runnable，被 getPostMessage 函数包装称 message
    - Runnable 被赋值到 message 的成员变量，m.callback = r;
  - 两种方法，最终都是调用 sendMessageDelayed
    - msg.target = this; //入队前，记录所属的 handler
    - queue.enqueueMessage(msg, uptimeMillis);
- 入队 MessageQueue#enqueueMessage()
  - 以链表形式存储
  - 如果表头为空 or 延迟时间为0 or 延迟时间比表头时间少，插入表头
  - 否则，插入队列中间或末尾，保证按 when 从小到大排序即可，when 相同的，后来后处理
- 消息循环  Looper.loop() 
  - for : msg = queue.next();  
  - msg.target.dispatchMessage(msg);） 
- 分发处理  Handler#dispatchMessage
  - post Runnable -- handleCallback(msg); -- callback.run
  - mCallback.handleMessage(msg)
  - handleMessage(msg)
