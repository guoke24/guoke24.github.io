---
layout:     post  
title:      "函数式编程"  
subtitle:   "让数据只有唯一的入口和出口"  
date:       2021-06-14 12:00:00  
author:     "GuoHao"  
header-img: "img/spring.jpg"  
catalog: true  
tags:  
    - Android  
    - JetPack

---

参考：
[重学安卓：是软件工程安全的 声明式 UI 扫盲干货](https://xiaozhuanlan.com/topic/2356748910)

## 什么是函数式编程？

以「纯函数」为基础的编程。「纯函数」和「普通函数」的区别：
- 「纯函数」只会从参数列表中那值，不会修改共享变量的值，只会从返回值返回结果。这样就保证了只有一个入口和一个出口，逻辑清晰，保持了一致性，减少出错的可能，便于维护。
- 「普通函数」，往往缺乏约束，自由散漫，在函数体内，随意的访问共享变量，且还会在后续的维护中，插入新的代码，入侵性强；这样的函数，在多人协同开发的工作模式下，容易出现不可预期的错误，不易维护，阅读时理解会有不同程度的障碍。

### 小结

> 不在函数内部执行与运算本身无关的其他操作，

> 不在函数内部调用外部变量、不修改从外部传进来的变量，

> （简言之就是，调用函数时 没有"副作用"，且 不改变初始状态）

## 为什么需要函数式编程？哪些情况需要函数式编程？

> 数据驱动、Java8 Stream、RxJava 等，本质上都是函数式编程。

<br>

> Flutter UI 的本质是 “数据驱动 UI 框架”，数据驱动的实现方式之一是函数式编程，且函数式编程的基石是纯函数。

<br>

> 函数式编程的存在，主要是为了 **从范式层面彻底解决 过程的一致性问题**。

> 数据驱动 UI 框架 主要是为了解决 **视图调用的一致性问题**。

说白了，就是为了编程时的**「一致性」**问题！

## 没有函数式编程的世界是怎么样的？

![](https://images.xiaozhuanlan.com/photo/2020/c18b86216f55b83e6726bcbf08b2b7bd.png)

> **一旦 TextView 成为共享变量，被分散到各个方法中，后续就不可控了**，因为当执行方法 B 时，方法 A 是无法知道 方法 B 中对共享变量做了什么，却无差别地承受 共享变量被修改 所带来的影响，

> 比如当 方法 B 将 TextView 置空，那么 方法 A 调用 TextView 实例时 将面临 null 安全问题。

## 引入函数式编程之后的世界又是怎么样的？

例子1：

![](https://images.xiaozhuanlan.com/photo/2020/67f4230cc99f9827db2fe21fb723dcdc.png)

RxJava 或 Java8 Stream 都是这样的「链式调用」的书写，规范统一，避免了入侵代码的可能。

> 从范式层面彻底解决 **过程的一致性问题** —— 有怎样的输入，就有且只有怎样的输出，关注点只有这两处，因集中管理 而从根本上杜绝了不可预期的结果。


例子2：

![](https://images.xiaozhuanlan.com/photo/2020/f47f2111348d4e927e446e37379df502.gif)

这就是数据驱动。

其实，无论是 React Native、Flutter 甚至是 Jetpack Compose 和 SwiftUI，都是基于这个思路。

> 它的本质是数据驱动，只有唯一入口、通过数据来驱动，

> 所以 视图逻辑，只能在 “用于返回给后台” 的声明树中编写、并且是结合 输入的状态 来指导逻辑的走向，

<br>

> 在数据驱动 UI 框架中，视图的隐藏不是直接 mView.setVisible(false) ，因为本来就是基于函数式编程 —— **你接触不到作为函数内部成员的 视图实例**（Flutter 称 Element），**你能左右的只有在函数入口** 作为入参的声明树（Flutter 称 Widget）——

> 也即，在数据驱动的背景下，无论是想要内部视图实例发生隐藏，还是别的什么状态的变化，**每次都只能 “重来一遍” —— 通过 setState 方法重新赋予状态值，并重走一次 render 方法来重建声明树**，最终后台会根据重建前后声明树的差异，来筛选出状态的变化逻辑，从而来决定内部真正视图实例的状态变化，如此来彻底规避上文提到的视图实例调用的 null 安全一致性问题。

## 数据驱动的好处

1，支持热重载；
2，UI 开发进一步精简化，可以交给外包，可以一键生成等等。

## 函数式编程的缺点

> 通过函数式编程，我们彻底地解决了因 "自由散漫" 而存在的 null 安全隐患 和 结果的不可再现，但函数式编程 "**只有一个入口" 和 基于递归算法的** "链式调用" ，**完全是在拿性能来换软工安全**。

> > 由于只有一个入口，每次状态发生改变，都不得不重走一次入口、重新生成整个布局树，然后在内部生成真正的视图树，或根据前后布局树的差异调整视图树。

> > 要知道，旧版 Android 视图系统，**为了将性能优化到极致，不顾代码的晦涩和丑陋** —— 比如在 MeasureSpec 中使用移位运算，而不是新建一个变量来存储测量模式；又如在事件分发过程中，通过 Flag 来存储和判断 "是否继续分发给子控件" 的信号，而不是每一次都重新运算一遍。

> 也即，函数式编程，客观来说，比较适合 "在子线程中运行的背景任务"，而不适合像 视图系统 这种，对实时响应的要求很高的密集型计算。(16ms 内就得完成一次完整的排版和渲染呢)

