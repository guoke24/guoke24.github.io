I"^+<ol>
  <li>
    <hr />
  </li>
  <li>layout:     post</li>
  <li>title:      “Android系统的第一个进程”</li>
  <li>subtitle:   “read the fxxking source code”</li>
  <li>date:       2019-09-26 12:00:00</li>
  <li>author:     “GuoHao”</li>
  <li>header-img: “img/waittouse.jpg”</li>
  <li>catalog: true</li>
  <li>tags:</li>
  <li>
    <ul>
      <li>Android</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>源码</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>进程</li>
    </ul>
  </li>
  <li>
    <ul>
      <li>init</li>
    </ul>
  </li>
  <li>
    <hr />
  </li>
</ol>

<h1 id="initcpp">init.cpp</h1>
<p>Android系统的第一个进程，是 init 进程，函数入口是 system/core/init/init.cpp 的 main 函数。</p>

<p>init 进程的 main 函数会去读取文件 init.rc，<br />
代码段1:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>    Parser&amp; parser = Parser::GetInstance();
    parser.AddSectionParser("service",std::make_unique&lt;ServiceParser&gt;());
    parser.AddSectionParser("on", std::make_unique&lt;ActionParser&gt;());
    parser.AddSectionParser("import", std::make_unique&lt;ImportParser&gt;());
    parser.ParseConfig("/init.rc");
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="initrc">init.rc</h1>
<p>init.rc 的路径为：/system/core/rootdir/init.rc<br />
代码段2:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>on nonencrypted
    # A/B update verifier that marks a successful boot.
    exec - root -- /system/bin/update_verifier nonencrypted
    class_start main //2-1
    class_start late_start
</pre></td></tr></tbody></table></code></pre></div></div>
<p>注释2-1处，意思就是去启动 classname 为 main 的 service。</p>

<h1 id="initzygote64rc">init.zygote64.rc</h1>
<p>那么，此时的 service，又是在哪里声明，定义的呢？
有这么一个配置文件：system/core/rootdir/init.zygote64.rc，当处理器是64位的时候就会读取它；<br />
代码段3:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server
    class main
    socket zygote stream 660 root system
    onrestart write /sys/android_power/request_state wake
    onrestart write /sys/power/state on
    onrestart restart audioserver
    onrestart restart cameraserver
    onrestart restart media
    onrestart restart netd
    writepid /dev/cpuset/foreground/tasks /dev/stune/foreground/tasks
</pre></td></tr></tbody></table></code></pre></div></div>
<p>此文件，
第一行：定义了一个service，名为 zygote，可执行文件的路径为 /system/bin/app_process64；<br />
第二行：定义了 classname 为 main。</p>

<p>这就是上述代码段2中指定的，将要被启动的 classname 为 main 的 service。<br />
再看，可执行文件的路径为 /system/bin/app_process64，注意 app_process64 是一个文件而不是目录。<br />
经过求证，这个文件是在设备上才有的，源码工程里没有。该可执行文件对应的源码工程内的文件是：<br />
/frameworks/base/cmds/app_process/app_main.cpp，<br />
同路径下，有个 Android.mk 文件，即 /frameworks/base/cmds/app_process/Android.mk，其代码有这么一段：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>LOCAL_MODULE:= app_process
LOCAL_MULTILIB := both
LOCAL_MODULE_STEM_32 := app_process32
LOCAL_MODULE_STEM_64 := app_process64
</pre></td></tr></tbody></table></code></pre></div></div>
<p>说明，/frameworks/base/cmds/app_process 这个子模块的代码会被编译成：
app_process，app_process32，app_process64 三种可执行文件，
然后根据处理器的位数，调用相应的可执行文件。</p>

<p>至于具体是谁，找到了 init.zygote64.rc 文件并且解析它，然后启动 zygote service 呢？</p>

<h1 id="servicecpp">service.cpp</h1>
<p>解析 init.zygote64.rc 文件的源码在：system/core/init/service.cpp，<br />
代码段4:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre>bool ServiceParser::ParseSection(const std::vector&lt;std::string&gt;&amp; args,
                                 std::string* err) {
    if (args.size() &lt; 3) {
        *err = "services must have a name and a program";
        return false;
    }

    const std::string&amp; name = args[1];
    if (!IsValidName(name)) {
        *err = StringPrintf("invalid service name '%s'", name.c_str());
        return false;
    }

    std::vector&lt;std::string&gt; str_args(args.begin() + 2, args.end());
    // 创建 service
    service_ = std::make_unique&lt;Service&gt;(name, "default", str_args);
    return true;
}

// 解析子项
bool ServiceParser::ParseLineSection(const std::vector&lt;std::string&gt;&amp; args,
                                     const std::string&amp; filename, int line,
                                     std::string* err) const {
    return service_ ? service_-&gt;HandleLine(args, err) : false;
}

// 所有数据解析完后调用该函数
void ServiceParser::EndSection() {
    if (service_) {
        ServiceManager::GetInstance().AddService(std::move(service_));
    }
}

// 添加 service 到链表
void ServiceManager::AddService(std::unique_ptr&lt;Service&gt; service) {
    Service* old_service = FindServiceByName(service-&gt;name());
    if (old_service) {
        ERROR("ignored duplicate definition of service '%s'",
              service-&gt;name().c_str());
        return;
    }
    // 最后将 service 加入 vector 类型的 service 链表
    services_.emplace_back(std::move(service));
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>启动 zygote service 的源码，也是在 system/core/init/service.cpp， 
这时要先看 init.rc，回顾代码段2:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>on nonencrypted
    # A/B update verifier that marks a successful boot.
    exec - root -- /system/bin/update_verifier nonencrypted
    class_start main //2-1
    class_start late_start
</pre></td></tr></tbody></table></code></pre></div></div>
<p>注释2-1处，class_start 其实是一个 COMMAND，会调用函数：do_class_start，
在 system/core/init/builtins.cpp 中定义了该函数，<br />
代码段5:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>static int do_class_start(const std::vector&lt;std::string&gt;&amp; args) {
        /* Starting a class does not start services
         * which are explicitly disabled.  They must
         * be started individually.
         */
    ServiceManager::GetInstance().
        ForEachServiceInClass(args[1], [] (Service* s) { s-&gt;StartIfNotDisabled(); });
    return 0;
}
</pre></td></tr></tbody></table></code></pre></div></div>
<p>ForEachServiceInClass 会遍历上述的 service 链表，找到 classname 为 main 的 zygote 后，执行 StartIfNotDisabled 函数去启动 zygote。<br />
源码定义在 system/core/init/service.cpp，<br />
代码段6:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="rouge-code"><pre>bool Service::StartIfNotDisabled() {
    if (!(flags_ &amp; SVC_DISABLED)) {
        return Start(); // 执行 Start 函数
    } else {
        flags_ |= SVC_DISABLED_START;
    }
    return true;
}

bool Service::Start() {
    // Starting a service removes it from the disabled or reset state and
    // immediately takes it out of the restarting state if it was in there.
    flags_ &amp;= (~(SVC_DISABLED|SVC_RESTARTING|SVC_RESET|SVC_RESTART|SVC_DISABLED_START));
    time_started_ = 0;

    // Running processes require no additional work --- if they're in the
    // process of exiting, we've ensured that they will immediately restart
    // on exit, unless they are ONESHOT.
    if (flags_ &amp; SVC_RUNNING) { // 如果 service 已经运行，则不启动
#ifdef MTK_INIT
        ERROR("service '%s' still running, return directly\n", name_.c_str());
#endif
        return false;
    }
    ......
    // 判断 service 对应的可执行文件是否存在，不存在则不启动
	struct stat sb;
    if (stat(args_[0].c_str(), &amp;sb) == -1) {
        ERROR("cannot find '%s' (%s), disabling '%s'\n",
              args_[0].c_str(), strerror(errno), name_.c_str());
        flags_ |= SVC_DISABLED;
        return false;
    }
    ......

    // 如果子进程没有启动，就调用 fork 函数创建子进程
	pid_t pid = fork();

    if (pid == 0) { // 当前代码逻辑在子进程中
        umask(077);
        ......

        // 执行 execve 函数，service 子进程就会被启动
        if (execve(args_[0].c_str(), (char**) &amp;strs[0], (char**) ENV) &lt; 0) {
            ERROR("cannot execve('%s'): %s\n", args_[0].c_str(), strerror(errno));
        }
        ......
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="小结">小结</h1>
<p>到此，可以粗略地小结一下：系统启动的前几个步骤为：<br />
init.cpp –&gt; init.rc –&gt; init.zygote64.rc –&gt; service.cpp –&gt; app_process64 –&gt; app_main.cpp
<br />
带上路径后，为：<br />
/system/core/init/init.cpp<br />
/system/core/rootdir/init.rc<br />
/system/core/rootdir/init.zygote64.rc<br />
/system/core/init/service.cpp<br />
/system/bin/app_process64<br />
/frameworks/base/cmds/app_process/app_main.cpp</p>

<p>可以看到，系统启动过程中，对应的源码从 /system/core 转移到了 /frameworks/base 。</p>

<p>但请注意，这是一个不严谨的流程，忽略了中间的很多逻辑，仅作临时记录，便于继续研究。</p>

:ET