I"–­<h1 id="å‰è¨€">å‰è¨€</h1>
<p>9æœˆåˆå†™çš„è¿™ç¯‡æ–‡ç« ï¼š<a href="https://guoke24.top/2019/09/02/V2åŠ ç­¾/">æºç çœ‹ Android V2 ç­¾åä¹‹åŠ ç­¾ç¯‡</a>ï¼Œä»æºç çš„è§’åº¦è§£æäº†åŠ ç­¾çš„è¿‡ç¨‹ï¼ŒåŒæ—¶ä¹Ÿäº†è§£äº†ç­¾å APK çš„ç»“æ„ï¼Œ
å¦‚ä¸‹å›¾ï¼š
<img src="http://guoke24.top/img/apk-before-after-signing.png" alt="" /><br /></p>

<p>è¿˜æœ‰ç­¾åå—çš„ç»“æ„ï¼Œç”¨ç±»jsonæ ¼å¼çš„ä»£ç è¡¨ç¤ºå¦‚ä¸‹ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>apk
{
    beforeCentralDir,
    apkSigningBlock,// apk ç­¾ååˆ†å—
		{
		    blockSizeFieldValue,
		    pairSizeFieldValue,
		    APK_SIGNATURE_SCHEME_V2_BLOCK_ID,
		    apkSignatureSchemeV2Blockï¼Œ// value å€¼ï¼Œå†…å« â€œID-å€¼â€å¯¹ï¼ŒV2 åˆ†å—
		    blockSizeFieldValue,
		    APK_SIGNING_BLOCK_MAGIC,
		}
    centralDir,
    eocd,
}
</pre></td></tr></tbody></table></code></pre></div></div>
<p>å†æ¥ä¸€å¼ è¡¨æ ¼å›¾ç¤ºï¼š<br />
<img src="http://guoke24.top/img/v2ç­¾åå—è¡¨æ ¼å›¾ç¤º.png" alt="" /><br /></p>

<h1 id="v2-éªŒç­¾çš„æºç å…¥å£">V2 éªŒç­¾çš„æºç å…¥å£</h1>

<p>æ¥ç€çœ‹æºç ï¼ŒéªŒç­¾çš„ä»£ç éƒ½æ˜¯åœ¨ framework/base å†…çš„ï¼Œå¯ä»¥é€šè¿‡è¯¥å‘½ä»¤ä¸‹è½½ framework/base ï¼ˆå¯èƒ½éœ€ç§‘å­¦ä¸Šç½‘ï¼‰ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>git clone https://android.googlesource.com/platform/frameworks/base

</pre></td></tr></tbody></table></code></pre></div></div>
<p>ä¹Ÿå¯ä»¥å»ç½‘ä¸Šæµè§ˆï¼ˆå¯èƒ½éœ€ç§‘å­¦ä¸Šç½‘ï¼‰ï¼Œç›´æ¥<a href="https://android.googlesource.com/platform/frameworks/base">ç‚¹å‡»è¯¥é“¾æ¥</a>ï¼›</p>

<p>æˆ‘ä»¬å…ˆæ‰¾ V2 éªŒç­¾çš„å‡½æ•°å…¥å£ï¼Œè¿™æ˜¯åœ¨å®‰è£… APK çš„è°ƒç”¨é“¾ä¸­çš„ä¸€ä¸ªåˆ†æ”¯ï¼Œå®šä¹‰åœ¨è¯¥æ–‡ä»¶ï¼š
/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java<br />
ä»£ç æ®µ1:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>    private void installPackageLI(InstallArgs args, PackageInstalledInfo res) {
......
        try {
            // either use what we've been given or parse directly from the APK
            if (args.signingDetails != PackageParser.SigningDetails.UNKNOWN) {
                pkg.setSigningDetails(args.signingDetails);
            } else {
                // 1-1
                PackageParser.collectCertificates(pkg, false /* skipVerify */);
            }
        } catch (PackageParserException e) {
            res.setError("Failed collect during installPackageLI", e);
            return;
        }
......
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ¥ç€åœ¨æ³¨é‡Š1-1å¤„ï¼Œæ‰§è¡Œ PackageParser ç±»çš„ collectCertificates å‡½æ•°ï¼Œ<br />
è¿›å…¥æ–‡ä»¶ï¼š<br />
/frameworks/base/core/java/android/content/pm/PackageParser.java<br />
ä»£ç æ®µ2:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre></td><td class="rouge-code"><pre>    /**
     * Collect certificates from all the APKs described in the given package,
     * populating {@link Package#mSigningDetails}. Also asserts that all APK
     * contents are signed correctly and consistently.
     */
    public static void collectCertificates(Package pkg, boolean skipVerify)
            throws PackageParserException {
        // 2-1 æ¥ç€ä¸‹ä¸€æ­¥
        collectCertificatesInternal(pkg, skipVerify);
        final int childCount = (pkg.childPackages != null) ? pkg.childPackages.size() : 0;
        for (int i = 0; i &lt; childCount; i++) {
            Package childPkg = pkg.childPackages.get(i);
            childPkg.mSigningDetails = pkg.mSigningDetails;
        }
    }



    private static void collectCertificatesInternal(Package pkg, boolean skipVerify)
            throws PackageParserException {
        pkg.mSigningDetails = SigningDetails.UNKNOWN;

        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "collectCertificates");
        try {
            // 2-2 æ¥ç€ä¸‹ä¸€æ­¥
            collectCertificates(pkg, new File(pkg.baseCodePath), skipVerify);

            if (!ArrayUtils.isEmpty(pkg.splitCodePaths)) {
                for (int i = 0; i &lt; pkg.splitCodePaths.length; i++) {
                    collectCertificates(pkg, new File(pkg.splitCodePaths[i]), skipVerify);
                }
            }
        } finally {
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }
    }



    private static void collectCertificates(Package pkg, File apkFile, boolean skipVerify)
            throws PackageParserException {
        final String apkPath = apkFile.getAbsolutePath();

        int minSignatureScheme = SigningDetails.SignatureSchemeVersion.JAR;
        if (pkg.applicationInfo.isStaticSharedLibrary()) {
            // must use v2 signing scheme
            minSignatureScheme = SigningDetails.SignatureSchemeVersion.SIGNING_BLOCK_V2;
        }
        SigningDetails verified;
        if (skipVerify) {
            // systemDir APKs are already trusted, save time by not verifying
            verified = ApkSignatureVerifier.plsCertsNoVerifyOnlyCerts(
                        apkPath, minSignatureScheme);
        } else {
            // 2-3 APK çš„éªŒç­¾å…¥å£
            verified = ApkSignatureVerifier.verify(apkPath, minSignatureScheme);
        }

        // Verify that entries are signed consistently with the first pkg
        // we encountered. Note that for splits, certificates may have
        // already been populated during an earlier parse of a base APK.
        if (pkg.mSigningDetails == SigningDetails.UNKNOWN) {
            pkg.mSigningDetails = verified;
        } else {
            if (!Signature.areExactMatch(pkg.mSigningDetails.signatures, verified.signatures)) {
                throw new PackageParserException(
                        INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES,
                        apkPath + " has mismatched certificates");
            }
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ³¨é‡Š2-3å¤„ï¼Œæ˜¯ APK çš„éªŒç­¾å…¥å£ï¼Œæ¥ç€æ¥åˆ°æ–‡ä»¶ï¼š
/frameworks/base/core/java/android/util/apk/ApkSignatureVerifier.java<br />
ä»£ç æ®µ3:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
</pre></td><td class="rouge-code"><pre>    /**
     * Verifies the provided APK and returns the certificates associated with each signer.
     *
     * @throws PackageParserException if the APK's signature failed to verify.
     */
    public static PackageParser.SigningDetails verify(String apkPath,
            @SignatureSchemeVersion int minSignatureSchemeVersion)
            throws PackageParserException {

        if (minSignatureSchemeVersion &gt; SignatureSchemeVersion.SIGNING_BLOCK_V3) {
            // V3 and before are older than the requested minimum signing version
            throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,
                    "No signature found in package of version " + minSignatureSchemeVersion
            + " or newer for package " + apkPath);
        }

        // first try v3
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "verifyV3");
        try {
            ApkSignatureSchemeV3Verifier.VerifiedSigner vSigner =
                    ApkSignatureSchemeV3Verifier.verify(apkPath);
            Certificate[][] signerCerts = new Certificate[][] { vSigner.certs };
            Signature[] signerSigs = convertToSignatures(signerCerts);
            Signature[] pastSignerSigs = null;
            int[] pastSignerSigsFlags = null;
            if (vSigner.por != null) {
                // populate proof-of-rotation information
                pastSignerSigs = new Signature[vSigner.por.certs.size()];
                pastSignerSigsFlags = new int[vSigner.por.flagsList.size()];
                for (int i = 0; i &lt; pastSignerSigs.length; i++) {
                    pastSignerSigs[i] = new Signature(vSigner.por.certs.get(i).getEncoded());
                    pastSignerSigsFlags[i] = vSigner.por.flagsList.get(i);
                }
            }
            return new PackageParser.SigningDetails(
                    signerSigs, SignatureSchemeVersion.SIGNING_BLOCK_V3,
                    pastSignerSigs, pastSignerSigsFlags);
        } 

        ......

        // try v2
        Trace.traceBegin(TRACE_TAG_PACKAGE_MANAGER, "verifyV2");
        try {
            // 3-1 V2 éªŒç­¾çš„æ­£å¼å…¥å£
            Certificate[][] signerCerts = ApkSignatureSchemeV2Verifier.verify(apkPath);
            Signature[] signerSigs = convertToSignatures(signerCerts);

            return new PackageParser.SigningDetails(
                    signerSigs, SignatureSchemeVersion.SIGNING_BLOCK_V2);
        } catch (SignatureNotFoundException e) {
            // not signed with v2, try older if allowed
            if (minSignatureSchemeVersion &gt;= SignatureSchemeVersion.SIGNING_BLOCK_V2) {
                throw new PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,
                        "No APK Signature Scheme v2 signature in package " + apkPath, e);
            }
        } catch (Exception e) {
            // APK Signature Scheme v2 signature found but did not verify
            throw new  PackageParserException(INSTALL_PARSE_FAILED_NO_CERTIFICATES,
                    "Failed to collect certificates from " + apkPath
                            + " using APK Signature Scheme v2", e);
        } finally {
            Trace.traceEnd(TRACE_TAG_PACKAGE_MANAGER);
        }

    ......

    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>åˆ°æ­¤ï¼Œåœ¨æ³¨è§†3-1å¤„ï¼Œæ‰¾åˆ°äº† V2 éªŒç­¾çš„å‡½æ•°å…¥å£ï¼š ApkSignatureSchemeV2Verifier.verify(apkPath);<br />
æ¥ç€çœ‹æºç ï¼Œæ¥åˆ°æ–‡ä»¶ï¼š<br />
/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java<br />
ä»£ç æ®µ4:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre>    /**
     * Verifies APK Signature Scheme v2 signatures of the provided APK and returns the certificates
     * associated with each signer.
     *
     * @throws SignatureNotFoundException if the APK is not signed using APK Signature Scheme v2.
     * @throws SecurityException if a APK Signature Scheme v2 signature of this APK does not verify.
     * @throws IOException if an I/O error occurs while reading the APK file.
     */
    public static X509Certificate[][] verify(String apkFile)
            throws SignatureNotFoundException, SecurityException, IOException {
        // 4-1 æ¥ç€ä¸‹ä¸€æ­¥
        VerifiedSigner vSigner = verify(apkFile, true);
        return vSigner.certs;
    }


    private static VerifiedSigner verify(String apkFile, boolean verifyIntegrity)
            throws SignatureNotFoundException, SecurityException, IOException {
        try (RandomAccessFile apk = new RandomAccessFile(apkFile, "r")) {
            // 4-2 æ¥ç€ä¸‹ä¸€æ­¥
            return verify(apk, verifyIntegrity);
        }
    }


    /**
     * Verifies APK Signature Scheme v2 signatures of the provided APK and returns the certificates
     * associated with each signer.
     *
     * @throws SignatureNotFoundException if the APK is not signed using APK Signature Scheme v2.
     * @throws SecurityException if an APK Signature Scheme v2 signature of this APK does not
     *         verify.
     * @throws IOException if an I/O error occurs while reading the APK file.
     */
    private static VerifiedSigner verify(RandomAccessFile apk, boolean verifyIntegrity)
            throws SignatureNotFoundException, SecurityException, IOException {
        // 4-3
        SignatureInfo signatureInfo = findSignature(apk);
        // 4-4
        return verify(apk, signatureInfo, verifyIntegrity);
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ç»è¿‡ä¸€ç³»åˆ—çš„è°ƒç”¨ï¼Œæˆ‘ä»¬æ¥åˆ°äº†å…³é”®çš„ä¸€æ­¥ï¼ŒV2 éªŒç­¾çš„ä¸»æµç¨‹ã€‚</p>

<h1 id="v2-éªŒç­¾çš„ä¸»æµç¨‹">V2 éªŒç­¾çš„ä¸»æµç¨‹</h1>
<p>éªŒç­¾çš„è¿‡ç¨‹ä¸»è¦åˆ†ä¸¤æ­¥ï¼š<br />
ç¬¬ä¸€ï¼Œä»£ç æ®µ4ä¸­çš„æ³¨é‡Š4-3ï¼Œæå–ç­¾åå—ï¼›<br />
ç¬¬äºŒï¼Œä»£ç æ®µ4ä¸­çš„æ³¨é‡Š4-4ï¼ŒéªŒè¯ç­¾åå—ã€‚</p>

<h1 id="v2-ç­¾åå—çš„æå–">V2 ç­¾åå—çš„æå–</h1>
<p>æ¥ç€ä»£ç æ®µ4ä¸­çš„æ³¨é‡Š4-3ï¼Œæ‰§è¡Œäº† findSignature å‡½æ•°ï¼Œæ¥åˆ°è¯¥æ–‡ä»¶ï¼š<br />
/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java<br />
ä»£ç æ®µ5:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>    /**
     * Returns the APK Signature Scheme v2 block contained in the provided APK file and the
     * additional information relevant for verifying the block against the file.
     *
     * @throws SignatureNotFoundException if the APK is not signed using APK Signature Scheme v2.
     * @throws IOException if an I/O error occurs while reading the APK file.
     */
    private static SignatureInfo findSignature(RandomAccessFile apk)
            throws IOException, SignatureNotFoundException {
        return ApkSigningBlockUtils.findSignature(apk, APK_SIGNATURE_SCHEME_V2_BLOCK_ID);
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ¥ç€æ‰§è¡Œ ApkSigningBlockUtils ç±» findSignature å‡½æ•°ï¼Œæ¥åˆ°æ–‡ä»¶ï¼š
/frameworks/base/core/java/android/util/apk/ApkSigningBlockUtils.java<br />
ä»£ç æ®µ6:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre>    /**
     * Returns the APK Signature Scheme block contained in the provided APK file and the
     * additional information relevant for verifying the block against the file.
     *
     * @param blockId the ID value in the APK Signing Block's sequence of ID-value pairs
     *                identifying the appropriate block to find, e.g. the APK Signature Scheme v2
     *                block ID.
     *
     * @throws SignatureNotFoundException if the APK is not signed using this scheme.
     * @throws IOException if an I/O error occurs while reading the APK file.
     */
    static SignatureInfo findSignature(RandomAccessFile apk, int blockId)
            throws IOException, SignatureNotFoundException {
        // Find the ZIP End of Central Directory (EoCD) record.
        Pair&lt;ByteBuffer, Long&gt; eocdAndOffsetInFile = getEocd(apk);
        ByteBuffer eocd = eocdAndOffsetInFile.first;
        long eocdOffset = eocdAndOffsetInFile.second;
        if (ZipUtils.isZip64EndOfCentralDirectoryLocatorPresent(apk, eocdOffset)) {
            throw new SignatureNotFoundException("ZIP64 APK not supported");
        }

        // Find the APK Signing Block. The block immediately precedes the Central Directory.
        long centralDirOffset = getCentralDirOffset(eocd, eocdOffset);
        Pair&lt;ByteBuffer, Long&gt; apkSigningBlockAndOffsetInFile =
                findApkSigningBlock(apk, centralDirOffset);
        ByteBuffer apkSigningBlock = apkSigningBlockAndOffsetInFile.first;
        long apkSigningBlockOffset = apkSigningBlockAndOffsetInFile.second;

        // Find the APK Signature Scheme Block inside the APK Signing Block.
        ByteBuffer apkSignatureSchemeBlock = findApkSignatureSchemeBlock(apkSigningBlock,
                blockId);

        return new SignatureInfo(
                apkSignatureSchemeBlock,
                apkSigningBlockOffset,
                centralDirOffset,
                eocdOffset,
                eocd);
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>å…ˆçœ‹åˆ°å‡½æ•°çš„æœ«å°¾ return äº†ä¸€ä¸ª SignatureInfo ç±»çš„å®ä¾‹ï¼Œå¹¶å…¥å‚äº†5ä¸ªå‚æ•°ï¼Œå¯çŸ¥å‰é¢çš„ä»£ç çš„ä½œç”¨å°±æ˜¯è·å–åˆ°è¿™5ä¸ªå‚æ•°çš„ã€‚ä»åå­—å¯ä»¥çœ‹å‡ºï¼Œè¿™5ä¸ªå‚æ•°åˆ†åˆ«è¡¨ç¤ºï¼šç­¾åå—ã€ç­¾åå—åç§»é‡ã€ä¸­å¤®ç›®å½•åŒºåç§»é‡ã€ä¸­å¤®ç»“å°¾åŒºåç§»é‡ã€ä¸­å¤®ç»“å°¾åŒºï¼›<br />
å¯çŸ¥éªŒç­¾çš„æ—¶å€™éœ€è¦ç”¨åˆ°è¿™å‡ ä¸ªå‚æ•°ã€‚<br />
å…¶ä¸­çš„ç­¾åå—ï¼ŒapkSignatureSchemeBlockï¼Œå¦‚ä¸‹å›¾æ‰€ç¤ºçš„çº¢è‰²å—ï¼š<br />
å†æ¬¡çœ‹åˆ°è¯¥å®˜æ–¹çš„å›¾ç‰‡ï¼š
<img src="http://guoke24.top/img/apk-before-after-signing.png" alt="" /><br /><br />
è¿™ä¸€æ­¥çš„ç›®çš„å°±æ˜¯æå–çº¢è‰²çš„ç­¾åå—ã€‚<br />
å…·ä½“æ€ä¹ˆè·å–è¿™å‡ ä¸ªå‚æ•°çš„æºç åˆ†æå…ˆçœç•¥äº†ï¼Œä¸»è¦å°±æ˜¯ zip æ–‡ä»¶æ ¼å¼çš„æ“ä½œã€‚<br />
ä¸‹é¢ç®€å•è®²ä¸€ä¸‹åŸç†ï¼š<br />
ç¬¬ä¸€ï¼Œæ ¹æ® eocd çš„æ ‡ç¤ºID 0x06054b50ï¼Œæ‰¾åˆ° eocd çš„å­—èŠ‚æ•°ç»„ã€‚<br />
ç¬¬äºŒï¼Œå†æˆªå– eocd çš„å­—èŠ‚æ•°ç»„ä¸­çš„èµ·å§‹ä¸‹æ ‡ä¸º16çš„å››ä¸ªå­—èŠ‚ï¼Œè½¬æ¢æˆ int ç±»å‹æ•°æ®çš„å€¼ï¼Œè¯¥æ•°å€¼å°±æ˜¯ centralDirOffset ï¼Œå³ä¸­å¤®ç›®å½•åŒºåç§»é‡ï¼Œæ­¤æ—¶å°±æ‰¾åˆ°äº†ä¸­å¤®ç›®å½•åŒºã€‚<br />
ç¬¬ä¸‰ï¼Œç´§æŒ¨ç€ä¸­å¤®ç›®å½•åŒºä¹‹å‰çš„æ˜¯16ä¸ªå­—èŠ‚é­”æ•°ï¼Œå†å¾€å‰çš„8ä¸ªå­—èŠ‚ï¼Œè¡¨ç¤ºç­¾åå—å­—èŠ‚æ•°çš„å¤§å°ã€‚å› ç¬¬äºŒéƒ¨å·²ç»å¾—çŸ¥ä¸­å¤®ç›®å½•åŒºåç§»é‡ï¼Œæ‰€ä»¥ç­¾åå—çš„å­—èŠ‚æ•°ç»„å’Œå…¶åç§»é‡éƒ½å¯ä»¥æ‰¾å‡ºæ¥äº†ã€‚</p>

<p>å†æ¥ä¸€å¼ è¡¨æ ¼å›¾ç¤ºï¼Œé…åˆç†è§£ï¼š<br />
<img src="http://guoke24.top/img/v2ç­¾åå—è¡¨æ ¼å›¾ç¤º.png" alt="" /><br /></p>

<p>å†ç”¨ä¸€ä¸ªå¸¦æœ‰åŸç”Ÿ V2 ç­¾åå’Œè‡ªå®šä¹‰ V2 æ ¼å¼ç­¾åçš„ APK çš„ä¾‹å­ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>50 4b 03 04 0a 00 00 08 // å†…å®¹åŒºstart
...
3c 04 00 00 2B 05 00 00 // å†…å®¹åŒºend
81 0c 00 00 00 00 00 00 // apkç­¾ååˆ†å—é•¿åº¦å‰ç¼€
D0 05 00 00 00 00 00 00 // v2ç­¾ååˆ†å—çš„é•¿åº¦å‰ç¼€
1a 87 09 71             // v2ç­¾ååˆ†å—çš„ID
....
92 ea 35 02 03 01 00 01 // v2ç­¾ååˆ†å—end
89 06 00 00 00 00 00 00 // è‡ªå®šä¹‰ç­¾ååˆ†å—é•¿åº¦å‰ç¼€
78 67 64 32             // è‡ªå®šä¹‰ç­¾ååˆ†å—çš„ID
....
7c 04 66 63 7d c2 b3 25 // è‡ªå®šä¹‰ç­¾ååˆ†å—end
81 0c 00 00 00 00 00 00 // apkç­¾ååˆ†å—é•¿åº¦åç¼€
.. .. .. .. .. .. .. .. 42 6c 6f 63 6b 20 34 32//é­”æ•°
50 4b 01 02 09 00 09 00 // cd ä¸­å¤®åŒº start
........... 2e 52 53 41 // cd ä¸­å¤®åŒº end
50 4b 05 06 // eocd ä¸­å¤®å°¾åŒº å¼€å¤´çš„æ ‡ç¤ºï¼Œå¤§ç«¯åºä¸º 06 05 4b 50
...
0f da c3 00 // cd ä¸­å¤®åŒº åç§»é‡
00 00 // eocd ä¸­å¤®å°¾åŒº end
</pre></td></tr></tbody></table></code></pre></div></div>

<p>åˆ°æ­¤æå–ç­¾åå—çš„åˆ†æå‘Šä¸€æ®µè½ã€‚</p>

<h1 id="v2-ç­¾åå—çš„éªŒè¯">V2 ç­¾åå—çš„éªŒè¯</h1>
<p>å†å›åˆ°ä»£ç æ®µ4ä¸­çš„æ³¨é‡Š4-4ï¼Œ<br />
/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>    private static VerifiedSigner verify(RandomAccessFile apk, boolean verifyIntegrity)
            throws SignatureNotFoundException, SecurityException, IOException {
        // 4-3
        SignatureInfo signatureInfo = findSignature(apk);
        // 4-4
        return verify(apk, signatureInfo, verifyIntegrity);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>æ³¨é‡Š4-4å¤„ï¼Œæ‰§è¡Œçš„ verify å‡½æ•°ï¼Œå»éªŒè¯ç­¾åå—ä¿¡æ¯ã€‚<br />
åœ¨çœ‹ä»£ç å‰ï¼Œå…ˆçœ‹çœ‹ç­¾åå—çš„ç»“æ„ï¼š<br />
<strong>ç­¾åå— v2 åˆ†å—</strong> ç”¨ç±»jsonæ ¼å¼ä»£ç è¡¨ç¤ºå¦‚ä¸‹ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>apkSignatureSchemeV2Blockï¼Œ// V2 åˆ†å—  
{
	len-signers[len-signer] // å¸¦é•¿åº¦å‰ç¼€çš„ç­¾åè€…é›†ï¼ˆå†…å«å¤šä¸ªç­¾åè€…ï¼‰
	{
		signer
		{
			len-signedData, //å¾…ç­¾åæ•°æ®
			{
				len-digests["len-(ç­¾åç®—æ³•ID-(len-æ‘˜è¦))"],  
				len-certificates["len-certificate"], //ä»ç¬¬ä¸€ä¸ª certificate å†…çš„å…¬é’¥ï¼Œå¯¹åº”ç­¾åçš„ç§é’¥
				len-additional_attributes["len-(ID-(len-attribute))"],  
			}
			len-signatures["len-(ç­¾åç®—æ³•ID-(len-signature))"], //ç­¾åå€¼ 
			len-publicKey // å…¬é’¥ï¼Œç¬¬ä¸€ä¸ª certificate å†…å–åˆ°çš„ 
		}
}
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ¥ç€çœ‹ä»£ç ï¼Œverify å‡½æ•°å®šä¹‰åœ¨è¯¥æ–‡ä»¶ï¼š<br />
/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java<br />
ä»£ç æ®µ7:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="rouge-code"><pre>    /**
     * Verifies the contents of the provided APK file against the provided APK Signature Scheme v2
     * Block.
     *
     * @param signatureInfo APK Signature Scheme v2 Block and information relevant for verifying it
     *        against the APK file.
     */
    private static VerifiedSigner verify(
            RandomAccessFile apk,
            SignatureInfo signatureInfo,
            boolean doVerifyIntegrity) throws SecurityException, IOException {
        int signerCount = 0;
        Map&lt;Integer, byte[]&gt; contentDigests = new ArrayMap&lt;&gt;();
        List&lt;X509Certificate[]&gt; signerCerts = new ArrayList&lt;&gt;();
        CertificateFactory certFactory;
        try {
            certFactory = CertificateFactory.getInstance("X.509");
        } catch (CertificateException e) {
            throw new RuntimeException("Failed to obtain X.509 CertificateFactory", e);
        }
        ByteBuffer signers;
        try {
            // 7-1
            // å…¥å‚çš„ signatureInfo.signatureBlock æ ¼å¼æ˜¯ len-signers[len-signer]
            // è¿”å›çš„ signers æ ¼å¼æ˜¯ signers[len-signer]
            signers = getLengthPrefixedSlice(signatureInfo.signatureBlock);
            // signers æ˜¯ä¸€ä¸ªç­¾åè€…é›†
        } catch (IOException e) {
            throw new SecurityException("Failed to read list of signers", e);
        }
        while (signers.hasRemaining()) { // æŠŠæ‰€æœ‰ç­¾åè€…é€ä¸ªå–å‡º
            signerCount++;
            try {
                // 7-2 è¿”å›çš„ signer æ˜¯ä¸å¸¦é•¿åº¦å‰ç¼€çš„ï¼Œå³æ˜¯ [len-signer] ä¸­çš„ signer
                ByteBuffer signer = getLengthPrefixedSlice(signers);
                // 7-3 éªŒè¯ signer,å³éªŒè¯ç­¾å
                X509Certificate[] certs = verifySigner(signer, contentDigests, certFactory);
                signerCerts.add(certs);
            } catch (IOException | BufferUnderflowException | SecurityException e) {
                throw new SecurityException(
                        "Failed to parse/verify signer #" + signerCount + " block",
                        e);
            }
        }

        if (signerCount &lt; 1) {
            throw new SecurityException("No signers found");
        }

        if (contentDigests.isEmpty()) {
            throw new SecurityException("No content digests found");
        }

        if (doVerifyIntegrity) {
            // 7-4 éªŒè¯æ‘˜è¦
            ApkSigningBlockUtils.verifyIntegrity(contentDigests, apk, signatureInfo);
        }

        byte[] verityRootHash = null;
        if (contentDigests.containsKey(CONTENT_DIGEST_VERITY_CHUNKED_SHA256)) {
            byte[] verityDigest = contentDigests.get(CONTENT_DIGEST_VERITY_CHUNKED_SHA256);
            verityRootHash = ApkSigningBlockUtils.parseVerityDigestAndVerifySourceLength(
                    verityDigest, apk.length(), signatureInfo);
        }

        // 7-5 åˆ°æ­¤å¤„é€šè¿‡éªŒè¯ï¼Œè¿”å›æ•°æ®ç»§ç»­ä¸‹ä¸€æ­¥æ“ä½œ
        return new VerifiedSigner(
                signerCerts.toArray(new X509Certificate[signerCerts.size()][]),
                verityRootHash);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>è¯¥æ®µä»£ç æ­ç¤ºäº†éªŒç­¾çš„ä¸»é€»è¾‘ï¼Œåˆ†ä¸¤æ­¥ï¼š<br />
ç¬¬ä¸€æ­¥ï¼šåœ¨æ³¨é‡Š7-3å¤„ï¼ŒéªŒè¯ç­¾åï¼›<br />
ç¬¬äºŒæ­¥ï¼šåœ¨æ³¨é‡Š7-4å¤„ï¼ŒéªŒè¯æ‘˜è¦ã€‚</p>

<h1 id="v2-ç­¾åå—-éªŒè¯ç­¾åå€¼">V2 ç­¾åå—-éªŒè¯ç­¾åå€¼</h1>
<p>é‚£ä¹ˆæˆ‘ä»¬æ¥ç€æ³¨é‡Š7-3å¤„æ‰§è¡Œçš„ verifySigner å‡½æ•°ï¼Œæ¥ç€çœ‹ä»£ç ï¼š<br />
/frameworks/base/core/java/android/util/apk/ApkSignatureSchemeV2Verifier.java <br />
ä»£ç æ®µ8ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
</pre></td><td class="rouge-code"><pre>    private static X509Certificate[] verifySigner(
            ByteBuffer signerBlock,
            Map&lt;Integer, byte[]&gt; contentDigests,
            CertificateFactory certFactory) throws SecurityException, IOException {

        // ä¸å¸¦é•¿åº¦å‰ç¼€çš„ signedData çš„ç»“æ„
        //		{
        //			len-digests["len-(ç­¾åç®—æ³•ID-(len-æ‘˜è¦))"],
        //			len-certificates["len-certificate"], //ä»ç¬¬ä¸€ä¸ª certificate å†…çš„å…¬é’¥ï¼Œå¯¹åº”ç­¾åçš„ç§é’¥
        //			len-additional_attributes["len-(ID-(len-attribute))"],
        //		}

        ByteBuffer signedData = getLengthPrefixedSlice(signerBlock);

        // ä¸å¸¦é•¿åº¦å‰ç¼€çš„ signatures çš„ç»“æ„
        // ["len-(ç­¾åç®—æ³•ID-(len-signature))"]
        ByteBuffer signatures = getLengthPrefixedSlice(signerBlock);

        // å…¬é’¥ï¼Œçº¯å­—èŠ‚æ•°ç»„
        byte[] publicKeyBytes = readLengthPrefixedByteArray(signerBlock);

        int signatureCount = 0;
        int bestSigAlgorithm = -1;
        byte[] bestSigAlgorithmSignatureBytes = null;
        List&lt;Integer&gt; signaturesSigAlgorithms = new ArrayList&lt;&gt;();
        while (signatures.hasRemaining()) {
            signatureCount++;
            try {
                // ä¸å¸¦é•¿åº¦å‰ç¼€çš„ signature çš„ç»“æ„ï¼š
                // [ç­¾åç®—æ³•ID-(len-signature)]
                ByteBuffer signature = getLengthPrefixedSlice(signatures);
                if (signature.remaining() &lt; 8) {
                    throw new SecurityException("Signature record too short");
                }
                // ä» [ç­¾åç®—æ³•ID-(len-signature)] ç»“æ„ä¸­å–å¾— "ç­¾åç®—æ³•ID"
                int sigAlgorithm = signature.getInt();
                signaturesSigAlgorithms.add(sigAlgorithm);
                if (!isSupportedSignatureAlgorithm(sigAlgorithm)) {
                    continue;
                }
                if ((bestSigAlgorithm == -1)
                        || (compareSignatureAlgorithm(sigAlgorithm, bestSigAlgorithm) &gt; 0)) {
                    // è®°å½•æœ€ä½³ç®—æ³• å’Œ å¯¹åº”çš„ç­¾åå€¼
                    bestSigAlgorithm = sigAlgorithm;
                    bestSigAlgorithmSignatureBytes = readLengthPrefixedByteArray(signature);
                }
            } catch (IOException | BufferUnderflowException e) {
                throw new SecurityException(
                        "Failed to parse signature record #" + signatureCount,
                        e);
            }
        }
        if (bestSigAlgorithm == -1) {
            if (signatureCount == 0) {
                throw new SecurityException("No signatures found");
            } else {
                throw new SecurityException("No supported signatures found");
            }
        }
        // =================================================
        // === åˆ°æ­¤ï¼Œå–åˆ°æœ€ä½³ç­¾åç®—æ³•ï¼Œä¿å­˜åœ¨å˜é‡ï¼šbestSigAlgorithm
        // === ä»¥åŠæœ€ä½³ç­¾åç®—æ³•å¯¹åº”çš„ç­¾åå€¼ï¼Œä¿å­˜åœ¨å˜é‡ï¼šbestSigAlgorithmSignatureBytes

        // ç­¾åç®—æ³• å¯¹åº”çš„ åŠ å¯†ç®—æ³•
        String keyAlgorithm = getSignatureAlgorithmJcaKeyAlgorithm(bestSigAlgorithm);

        Pair&lt;String, ? extends AlgorithmParameterSpec&gt; signatureAlgorithmParams =
                getSignatureAlgorithmJcaSignatureAlgorithm(bestSigAlgorithm);

        String jcaSignatureAlgorithm = signatureAlgorithmParams.first;
        AlgorithmParameterSpec jcaSignatureAlgorithmParams = signatureAlgorithmParams.second;
        boolean sigVerified;
        try {
            PublicKey publicKey =
                    KeyFactory.getInstance(keyAlgorithm)// æ ¹æ® åŠ å¯†ç®—æ³• å’Œ ç­¾åå—ä¸­å–åˆ°çš„å…¬é’¥å­—èŠ‚æ•°ç»„ ï¼Œç”Ÿæˆå…¬é’¥å®ä¾‹
                            .generatePublic(new X509EncodedKeySpec(publicKeyBytes));

            Signature sig = Signature.getInstance(jcaSignatureAlgorithm);
            sig.initVerify(publicKey);// å¡«å…¥ å…¬é’¥
            if (jcaSignatureAlgorithmParams != null) {
                sig.setParameter(jcaSignatureAlgorithmParams);
            }
            sig.update(signedData);// å¡«å…¥ å¾…ç­¾åæ•°æ®
            sigVerified = sig.verify(bestSigAlgorithmSignatureBytes);// éªŒè¯ ç­¾åå€¼
        } catch (NoSuchAlgorithmException | InvalidKeySpecException | InvalidKeyException
                | InvalidAlgorithmParameterException | SignatureException e) {
            throw new SecurityException(
                    "Failed to verify " + jcaSignatureAlgorithm + " signature", e);
        }
        if (!sigVerified) {
            throw new SecurityException(jcaSignatureAlgorithm + " signature did not verify");
        }

        // Signature over signedData has verified.
        // ç¿»è¯‘ï¼šç­¾åå€¼ å’Œ å¾…ç­¾åæ•°æ® é€šè¿‡éªŒè¯

        byte[] contentDigest = null;
        signedData.clear();
        // digests çš„æ ¼å¼ä¸º ["len-(ç­¾åç®—æ³•ID-(len-æ‘˜è¦))"]
        ByteBuffer digests = getLengthPrefixedSlice(signedData);
        List&lt;Integer&gt; digestsSigAlgorithms = new ArrayList&lt;&gt;();
        int digestCount = 0;
        while (digests.hasRemaining()) {
            digestCount++;
            try {
                // digest çš„æ ¼å¼ä¸º "ç­¾åç®—æ³•ID-(len-æ‘˜è¦)"
                ByteBuffer digest = getLengthPrefixedSlice(digests);
                if (digest.remaining() &lt; 8) {
                    throw new IOException("Record too short");
                }
                // å–åˆ°çš„æ˜¯ "ç­¾åç®—æ³•ID-(len-æ‘˜è¦)" æ ¼å¼ä¸­çš„ ç­¾åç®—æ³•ID
                int sigAlgorithm = digest.getInt();
                digestsSigAlgorithms.add(sigAlgorithm);
                if (sigAlgorithm == bestSigAlgorithm) {
                    // å– æœ€ä½³ç­¾åç®—æ³• å¯¹åº”çš„ æ‘˜è¦å€¼
                    contentDigest = readLengthPrefixedByteArray(digest);
                }
            } catch (IOException | BufferUnderflowException e) {
                throw new IOException("Failed to parse digest record #" + digestCount, e);
            }
        }

        if (!signaturesSigAlgorithms.equals(digestsSigAlgorithms)) {
            throw new SecurityException(
                    "Signature algorithms don't match between digests and signatures records");
        }
        // æœ€ä½³ç­¾åç®—æ³• å¯¹åº”çš„ æ‘˜è¦ç®—æ³•
        int digestAlgorithm = getSignatureAlgorithmContentDigestAlgorithm(bestSigAlgorithm);
        // "æ‘˜è¦ç®—æ³• - æ‘˜è¦å€¼" çš„æ˜ å°„
        byte[] previousSignerDigest = contentDigests.put(digestAlgorithm, contentDigest);
        if ((previousSignerDigest != null)
                &amp;&amp; (!MessageDigest.isEqual(previousSignerDigest, contentDigest))) {
            throw new SecurityException(
                    getContentDigestAlgorithmJcaDigestAlgorithm(digestAlgorithm)
                    + " contents digest does not match the digest specified by a preceding signer");
        }

        // certificates çš„æ ¼å¼ä¸º ["len-certificate"]
        ByteBuffer certificates = getLengthPrefixedSlice(signedData);
        List&lt;X509Certificate&gt; certs = new ArrayList&lt;&gt;();
        int certificateCount = 0;
        while (certificates.hasRemaining()) {
            certificateCount++;
            // "len-certificate" æ ¼å¼ä¸­çš„ certificateï¼Œç»è¿‡ç¼–ç çš„
            byte[] encodedCert = readLengthPrefixedByteArray(certificates);
            X509Certificate certificate;
            try {
                certificate = (X509Certificate)
                        certFactory.generateCertificate(new ByteArrayInputStream(encodedCert));
            } catch (CertificateException e) {
                throw new SecurityException("Failed to decode certificate #" + certificateCount, e);
            }
            certificate = new VerbatimX509Certificate(
                    certificate, encodedCert);

            // ç»è¿‡å¤„ç†åçš„è¯ä¹¦ï¼Œæ”¾å…¥å˜é‡ certs
            certs.add(certificate);
        }

        if (certs.isEmpty()) {
            throw new SecurityException("No certificates listed");
        }
        X509Certificate mainCertificate = certs.get(0);
        byte[] certificatePublicKeyBytes = mainCertificate.getPublicKey().getEncoded();
        if (!Arrays.equals(publicKeyBytes, certificatePublicKeyBytes)) {
            throw new SecurityException(
                    "Public key mismatch between certificate and signature record");
        }

        // éªŒè¯ä¸€ä¸‹é™„åŠ æ•°æ®
        ByteBuffer additionalAttrs = getLengthPrefixedSlice(signedData);
        verifyAdditionalAttributes(additionalAttrs);

        // æ€»çš„æ¥è¯´ï¼Œè¯¥å‡½æ•°çš„é€»è¾‘åŒ…æ‹¬ï¼š
        // å–åˆ°æœ€ä½³ç®—æ³•
        // éªŒè¯ç­¾åï¼ˆæœ€ä½³ç®—æ³•å¯¹åº”çš„ç­¾åå€¼ï¼‰
        // æ ¹æ®æœ€ä½³ç®—æ³•ï¼Œå–åˆ°æ‘˜è¦ï¼Œä¿å­˜åˆ°å˜é‡ contentDigestsï¼ˆè¿˜æ²¡éªŒè¯ï¼‰
        // æå–è¯ä¹¦ï¼Œå¤„ç†ç¼–ç åï¼Œä¿å­˜åˆ°å˜é‡ certs
        // è¿”å›è¯ä¹¦æ•°ç»„
        return certs.toArray(new X509Certificate[certs.size()]);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>è¯¥æ®µå‡½æ•°ä¸»è¦çš„æµç¨‹éƒ½å†™äº†æ³¨é‡Šï¼Œè®°å¾—é…åˆ<strong>ç­¾åå—ç»“æ„çš„ç±»jsonæ ¼å¼çš„ä»£ç </strong>ä¸€èµ·çœ‹ã€‚ 
å¦‚æœå¯¹ç­¾åå—çš„ç»“æ„ä¸äº†è§£ï¼Œå¯ä»¥å…ˆçœ‹è¿™ç¯‡æ–‡ç« ï¼š<a href="https://guoke24.top/2019/09/02/V2åŠ ç­¾/">æºç çœ‹ Android V2 ç­¾åä¹‹åŠ ç­¾ç¯‡</a></p>

<h1 id="v2-ç­¾åå—-éªŒè¯æ‘˜è¦å€¼">V2 ç­¾åå—-éªŒè¯æ‘˜è¦å€¼</h1>
<p>æ¥ç€ä»£ç æ®µ7ä¸­æ³¨é‡Š7-4å¤„ï¼Œæ‰§è¡Œçš„ ApkSigningBlockUtils ç±»çš„ verifyIntegrity å‡½æ•°ï¼Œæ¥ç€çœ‹ä»£ç ï¼š 
/frameworks/base/core/java/android/util/apk/ApkSigningBlockUtils.java<br />
ä»£ç æ®µ9:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="rouge-code"><pre>    static void verifyIntegrity(
            Map&lt;Integer, byte[]&gt; expectedDigests,
            RandomAccessFile apk,
            SignatureInfo signatureInfo) throws SecurityException {
        // å…¥å‚çš„ expectedDigests æ˜¯ä¸€ä¸ªæ˜ å°„"æ‘˜è¦ç®—æ³• -æ‘˜è¦å€¼"

        if (expectedDigests.isEmpty()) {
            throw new SecurityException("No digests provided");
        }

        boolean neverVerified = true;

        Map&lt;Integer, byte[]&gt; expected1MbChunkDigests = new ArrayMap&lt;&gt;();
        if (expectedDigests.containsKey(CONTENT_DIGEST_CHUNKED_SHA256)) {
            expected1MbChunkDigests.put(CONTENT_DIGEST_CHUNKED_SHA256,
                    expectedDigests.get(CONTENT_DIGEST_CHUNKED_SHA256));
        }
        if (expectedDigests.containsKey(CONTENT_DIGEST_CHUNKED_SHA512)) {
            expected1MbChunkDigests.put(CONTENT_DIGEST_CHUNKED_SHA512,
                    expectedDigests.get(CONTENT_DIGEST_CHUNKED_SHA512));
        }
        // 9-1,CHUNKED_SHA256 å’Œ CHUNKED_SHA512 ç®—æ³•,èµ°è¿™ä¸ªéªŒè¯é€»è¾‘
        if (!expected1MbChunkDigests.isEmpty()) {
            try {
                verifyIntegrityFor1MbChunkBasedAlgorithm(expected1MbChunkDigests, apk.getFD(),
                        signatureInfo);
                neverVerified = false;
            } catch (IOException e) {
                throw new SecurityException("Cannot get FD", e);
            }
        }

        // 9-2,VERITY_CHUNKED_SHA256 ç®—æ³•,èµ°è¿™ä¸ªéªŒè¯é€»è¾‘
        if (expectedDigests.containsKey(CONTENT_DIGEST_VERITY_CHUNKED_SHA256)) {
            verifyIntegrityForVerityBasedAlgorithm(
                    expectedDigests.get(CONTENT_DIGEST_VERITY_CHUNKED_SHA256), apk, signatureInfo);
            neverVerified = false;
        }

        if (neverVerified) { // æ²¡é€šè¿‡éªŒè¯ï¼ŒæŠ›å¼‚å¸¸
            throw new SecurityException("No known digest exists for integrity check");
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ç”±æ³¨é‡Š9-1å’Œ9-2å¤„ï¼Œå¯çŸ¥ï¼š<br />
è‹¥æ‘˜è¦ç®—æ³•ä¸º CHUNKED_SHA256 æˆ– CHUNKED_SHA512ï¼Œæ‰§è¡Œ verifyIntegrityFor1MbChunkBasedAlgorithm å‡½æ•°æ¥éªŒè¯ï¼›<br />
è‹¥æ‘˜è¦ç®—æ³•ä¸º VERITY_CHUNKED_SHA25ï¼Œæ‰§è¡Œ verifyIntegrityForVerityBasedAlgorithm å‡½æ•°æ¥éªŒè¯ã€‚<br />
æˆ‘ä»¬æ¥ç€æ³¨é‡Š9-1çš„ verifyIntegrityFor1MbChunkBasedAlgorithm å‡½æ•°ï¼Œçœ‹ä»£ç ï¼š<br />
/frameworks/base/core/java/android/util/apk/ApkSigningBlockUtils.java<br />
ä»£ç æ®µ10:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="rouge-code"><pre>    private static void verifyIntegrityFor1MbChunkBasedAlgorithm(
            Map&lt;Integer, byte[]&gt; expectedDigests,
            FileDescriptor apkFileDescriptor,
            SignatureInfo signatureInfo) throws SecurityException {
        // We need to verify the integrity of the following three sections of the file:
        // 1. Everything up to the start of the APK Signing Block.
        // 2. ZIP Central Directory.
        // 3. ZIP End of Central Directory (EoCD).
        // Each of these sections is represented as a separate DataSource instance below.

        // To handle large APKs, these sections are read in 1 MB chunks using memory-mapped I/O to
        // avoid wasting physical memory. In most APK verification scenarios, the contents of the
        // APK are already there in the OS's page cache and thus mmap does not use additional
        // physical memory.
        DataSource beforeApkSigningBlock =
                new MemoryMappedFileDataSource(apkFileDescriptor, 0,
                        signatureInfo.apkSigningBlockOffset);
        DataSource centralDir =
                new MemoryMappedFileDataSource(
                        apkFileDescriptor, signatureInfo.centralDirOffset,
                        signatureInfo.eocdOffset - signatureInfo.centralDirOffset);

        // For the purposes of integrity verification, ZIP End of Central Directory's field Start of
        // Central Directory must be considered to point to the offset of the APK Signing Block.
        ByteBuffer eocdBuf = signatureInfo.eocd.duplicate();
        eocdBuf.order(ByteOrder.LITTLE_ENDIAN);
        ZipUtils.setZipEocdCentralDirectoryOffset(eocdBuf, signatureInfo.apkSigningBlockOffset);
        DataSource eocd = new ByteBufferDataSource(eocdBuf);

        int[] digestAlgorithms = new int[expectedDigests.size()];
        int digestAlgorithmCount = 0;

        // è¿™é‡Œå‡è®¾å…¥å‚çš„ expectedDigests å¸¦æœ‰å¤šä¸ª"æ‘˜è¦ç®—æ³•-æ‘˜è¦å€¼"çš„æ˜ å°„å¯¹
        for (int digestAlgorithm : expectedDigests.keySet()) {
            digestAlgorithms[digestAlgorithmCount] = digestAlgorithm;
            digestAlgorithmCount++;
        }
        byte[][] actualDigests;
        try {
            actualDigests =
                    computeContentDigestsPer1MbChunk(
                            digestAlgorithms,
                            new DataSource[] {beforeApkSigningBlock, centralDir, eocd});
        } catch (DigestException e) {
            throw new SecurityException("Failed to compute digest(s) of contents", e);
        }

        // åŒæ‘˜è¦ç®—æ³•ä¸‹ï¼Œå¯¹æ¯” å®é™…æ‘˜è¦å€¼ å’Œ æœŸæœ›æ‘˜è¦å€¼
        for (int i = 0; i &lt; digestAlgorithms.length; i++) {
            int digestAlgorithm = digestAlgorithms[i];
            byte[] expectedDigest = expectedDigests.get(digestAlgorithm);
            byte[] actualDigest = actualDigests[i];
            if (!MessageDigest.isEqual(expectedDigest, actualDigest)) {
                throw new SecurityException(
                        getContentDigestAlgorithmJcaDigestAlgorithm(digestAlgorithm)
                                + " digest of contents did not verify");
            }
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æˆ‘ä»¬å†æ¥ç€ä»£ç æ®µ9ä¸­çš„æ³¨é‡Š9-2å¤„çš„ verifyIntegrityForVerityBasedAlgorithm å‡½æ•°ï¼Œæ¥ç€çœ‹ä»£ç ï¼š<br />
/frameworks/base/core/java/android/util/apk/ApkSigningBlockUtils.java<br />
ä»£ç æ®µ10:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>    private static void verifyIntegrityForVerityBasedAlgorithm(
            byte[] expectedDigest,
            RandomAccessFile apk,
            SignatureInfo signatureInfo) throws SecurityException {
        try {
            // æœŸæœ›çš„hashå€¼
            byte[] expectedRootHash = parseVerityDigestAndVerifySourceLength(expectedDigest,
                    apk.length(), signatureInfo);
            // verity å¸¦æœ‰å®é™…çš„hashå€¼
            ApkVerityBuilder.ApkVerityResult verity = ApkVerityBuilder.generateApkVerity(apk,
                    signatureInfo, new ByteBufferFactory() {
                        @Override
                        public ByteBuffer create(int capacity) {
                            return ByteBuffer.allocate(capacity);
                        }
                    });
            // è¿›è¡Œæ¯”è¾ƒ
            if (!Arrays.equals(expectedRootHash, verity.rootHash)) {
                throw new SecurityException("APK verity digest of contents did not verify");
            }
        } catch (DigestException | IOException | NoSuchAlgorithmException e) {
            throw new SecurityException("Error during verification", e);
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>åˆ°æ­¤éªŒç­¾çš„ä»£ç å°±è´´å®Œäº†ã€‚æœ¬æ–‡ç« ä¸»è¦æ˜¯å¯¹çœ¼å‰çš„æµç¨‹åšä¸€ä¸ªå¤§è‡´çš„è®°å½•ï¼Œå¦‚æœéœ€è¦è¯¦ç»†çš„ç ”ç©¶ï¼Œè¿˜æ˜¯å¾—å–çœ‹æºç ã€‚</p>

:ET