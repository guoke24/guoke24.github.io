I"w€<h3 id="å‰è¨€">å‰è¨€</h3>
<p>å…³äºViewçš„äº‹ä»¶åˆ†å‘æœºåˆ¶ï¼Œç½‘ä¸Šå·²ç»æœ‰å¾ˆå¤šçš„èµ„æ–™ï¼Œä½†æ˜¯çº¸ä¸Šå¾—æ¥ç»ˆè§‰æµ…å‘€ï¼Œæ‰€ä»¥è‡ªå·±åŠ¨æ‰‹ç†äº†ä¸€éï¼Œå¹¶å†™ä¸‹è¯¥æ–‡ç« ä½œä¸ºè®°å½•ã€‚</p>

<h3 id="èƒŒæ™¯çŸ¥è¯†">èƒŒæ™¯çŸ¥è¯†</h3>

<ul>
  <li>é¡µé¢æ„æˆ <br />
åœ¨ Android ç³»ç»Ÿä¸­ï¼Œä¸€ä¸ªé¡µé¢ä¸€èˆ¬ç”¨ Activity ç±»æ¥å®ç°ã€‚
ä¸€ä¸ª Activity ä¼šæŒæœ‰ä¸€ä¸ª PhoneWindowï¼Œè€Œ PhoneWindow æœ‰æŒæœ‰ä¸€ä¸ª DecorViewï¼Œè¿™ä¸ª DecorView å°±æ˜¯æ•´ä¸ªé¡µé¢çš„æ ¹Viewäº†ï¼ŒDecorView å…¶å®æ˜¯ä¸€ä¸ª ViewGroupï¼Œå…¶å†…éƒ¨å«æœ‰ä¸º title å’Œ content ä¸¤ä¸ªLayoutåŒºåŸŸï¼›
å½“æˆ‘ä»¬è°ƒç”¨ Activity çš„ setContentView() å‡½æ•°ä¼ è¿›çš„ xml å¸ƒå±€æ–‡ä»¶ï¼Œå°†ä¼šä½œä¸º DecorView ä¸­çš„ content åŒºåŸŸçš„å­ View ã€‚<br />
Activity æ„æˆçš„ä¸€ç§æ¡ˆä¾‹ï¼š
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="err">ç¬¬0å±‚ï¼šDecorView</span>
-ç¬¬1å±‚ï¼Œç¬¬1ä¸ªViewï¼šLinearLayout ï¼ˆscreen_simple.xmlï¼‰
<span class="gd">--ç¬¬2å±‚ï¼Œç¬¬1ä¸ªViewï¼šViewStub
--ç¬¬2å±‚ï¼Œç¬¬2ä¸ªViewï¼šFrameLayoutï¼ˆè£…è½½ activity_my.xml çš„çˆ¶å®¹å™¨ï¼Œid ä¸º contentï¼‰
---ç¬¬3å±‚ï¼Œç¬¬1ä¸ªViewï¼šLinearLayoutï¼ˆactivity_my.xml ï¼‰
----ç¬¬4å±‚ï¼Œç¬¬1ä¸ªViewï¼šTextView
</span></pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
  <li>è§¦æ‘¸äº‹ä»¶åˆ†ç±»<br />
å½“æˆ‘ä»¬åœ¨æ‰‹æœºå±å¹•ä¸Šè¿›è¡Œç‚¹å‡»ï¼Œé•¿æŒ‰æˆ–è€…æ»‘åŠ¨ç­‰æ“ä½œï¼Œå¯¹äº Android ç³»ç»Ÿæ¥è¯´ï¼Œå°±æ˜¯ä¸€æ¬¡äº‹ä»¶åºåˆ—ï¼Œè¯¥äº‹ä»¶åºåˆ—ä¸­å«æœ‰ä¸‰ç§äº‹ä»¶ç±»å‹ï¼š</li>
  <li>Down</li>
  <li>Move</li>
  <li>
    <p>Up
è¿™ä¸€æ¬¡ç³»åˆ—çš„äº‹ä»¶åºåˆ—ï¼Œä¼šä» Activity ä¼ é€’åˆ° DecorViewï¼Œå†ä¼ é€’ç»™ DecorView çš„å„ä¸ªå­ Viewï¼Œç›´åˆ°æ‰¾åˆ°å¤„ç†äº‹ä»¶çš„å­Viewï¼Œç§°ä¸º targetã€‚<br />
ä» Activity åˆ° DecorView çš„ä¼ é€’çš„æºç ï¼Œå¯ä»¥å‚è€ƒè¯¥<a href="https://jsonchao.github.io/2018/10/17/Androidè§¦æ‘¸äº‹ä»¶ä¼ é€’æœºåˆ¶/">é“¾æ¥</a>ã€‚<br /></p>
  </li>
  <li>ç”¨ä¼ªä»£ç æ¥çœ‹æ•´ä½“é€»è¾‘
å¼•ç”¨<a href="https://www.jianshu.com/p/238d1b753e64">è¯¥é“¾æ¥</a>çš„ä¼ªä»£ç æ¥è¡¨ç¤ºæ•´ä½“é€»è¾‘<br />
ViewGroup#dispatchTouchEvent çš„ ä¼ªä»£ç ï¼š<br />
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre>// ViewGroup

  public boolean dispatchTouchEvent(MotionEvent ev) {
      boolean consume = false;// äº‹ä»¶æ˜¯å¦è¢«æ¶ˆè´¹

      if ( !onInterceptTouchEvent(ev) ){ // åˆ¤æ–­æ˜¯å¦æ‹¦æˆªäº‹ä»¶
      //ä¸æ‹¦æˆªï¼Œè°ƒç”¨å­Viewçš„dispatchTouchEventæ–¹æ³•
      forå¾ªç¯ï¼šconsume = child.dispatchTouchEvent(ev);
      }
		
  // å¦‚æœæ‹¦æˆªï¼Œæˆ–è€…æ²¡æœ‰å­ View æ¶ˆè´¹ï¼Œconsume éƒ½ä¸º false
  // æ­¤æ—¶ä¼šè°ƒç”¨è‡ªèº«çš„ onTouchEvent æ–¹æ³•
  if ( !consume ) onTouchEvent(ev); 

  //è¿”å›å€¼è¡¨ç¤ºäº‹ä»¶æ˜¯å¦è¢«æ¶ˆè´¹ï¼Œtrue äº‹ä»¶ç»ˆæ­¢ï¼Œfalse åˆ™è°ƒç”¨çˆ¶ View çš„ onTouchEventæ–¹æ³•
      return consume;
  }
</pre></td></tr></tbody></table></code></pre></div>    </div>
    <p>View#dispatchTouchEvent çš„ä¼ªä»£ç ï¼š<br /></p>
    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre>// View

  public boolean dispatchTouchEvent(MotionEvent ev) {
      boolean consume = false;//äº‹ä»¶æ˜¯å¦è¢«æ¶ˆè´¹

      if ( onTouch(ev) ) { //åˆ¤æ–­æ˜¯å¦æ‹¦æˆªäº‹ä»¶
      return true;
      }
		
  if ( onTouchEvent(ev) ) { //åˆ¤æ–­æ˜¯å¦æ‹¦æˆªäº‹ä»¶
      return true;
      }

  //è¿”å›å€¼è¡¨ç¤ºäº‹ä»¶æ˜¯å¦è¢«æ¶ˆè´¹ï¼Œtrueäº‹ä»¶ç»ˆæ­¢ï¼Œfalseè°ƒç”¨çˆ¶Viewçš„onTouchEventæ–¹æ³•
      return consume;
  }
</pre></td></tr></tbody></table></code></pre></div>    </div>
  </li>
</ul>

<p>ä»è¯¥æ®µä¼ªä»£ç ä¸­æå–å‡ºï¼š</p>
<ul>
  <li>ViewGroup#dispatchTouchEvent
    <ul>
      <li>
        <ol>
          <li>onInterceptTouchEvent æ‹¦æˆªåˆ¤æ–­</li>
        </ol>
      </li>
      <li>
        <ol>
          <li>child.dispatchTouchEvent åˆ†å‘å­ç±»
            <ul>
              <li>View#onTouch</li>
              <li>View#onTouchEvent  â€“ onClick</li>
            </ul>
          </li>
        </ol>
      </li>
      <li>
        <ol>
          <li>onTouchEvent è‡ªå¤„ç†</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p>ä¸‹é¢è¿›å…¥æ­£é¢˜ï¼š
äº‹ä»¶çš„åˆ†å‘ï¼Œä»æ ¹ ViewGroup å¼€å§‹çœ‹ï¼š</p>
<h3 id="é¦–å…ˆäº‹ä»¶ä¼ åˆ°æ ¹-viewgroup-çš„åˆ†å‘å‡½æ•°-dispatchtoucheventåˆ¤æ–­æ˜¯å¦æ‹¦æˆª">é¦–å…ˆï¼Œäº‹ä»¶ä¼ åˆ°æ ¹ ViewGroup çš„åˆ†å‘å‡½æ•° dispatchTouchEventï¼Œåˆ¤æ–­æ˜¯å¦æ‹¦æˆª</h3>
<p>ä»£ç æ®µä¸€ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre></td><td class="rouge-code"><pre>//  ViewGroup ç±»

    @Override
    public boolean dispatchTouchEvent(MotionEvent ev) {
        boolean handled = false;
        if (onFilterTouchEventForSecurity(ev)) {
            final int action = ev.getAction();
            final int actionMasked = action &amp; MotionEvent.ACTION_MASK;

            // Handle an initial down.
            if (actionMasked == MotionEvent.ACTION_DOWN) {
                // Throw away all previous state when starting a new touch gesture.
                // The framework may have dropped the up or cancel event for the previous gesture
                // due to an app switch, ANR, or some other state change.
                cancelAndClearTouchTargets(ev);// ç½®ç©º mFirstTouchTarget
                resetTouchState();
                // é‡ç½® mGroupFlagsï¼š
                // mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
                // mGroupFlags ä¼šä¸ FLAG_DISALLOW_INTERCEPT åšä½è¿ç®—
            }

            // Check for interception.
            final boolean intercepted;
            if (actionMasked == MotionEvent.ACTION_DOWN
                    || mFirstTouchTarget != null) {
                // èƒ½è¿›æ¥è¿™é‡Œï¼Œåªæœ‰ä¸¤ç§æƒ…å†µï¼š
                // downï¼ŒmFirstTouchTarget ä¸ºç©ºï¼Œåˆšåˆšè¢«é‡ç½®
                // move/upï¼ŒmFirstTouchTarget ä¸ä¸ºç©ºï¼Œæœ‰å­ View æ¶ˆè´¹äº‹ä»¶

                final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;// 1-1
                // å½“ç¬¬ä¸€ç§æƒ…å†µï¼šdownæ—¶ï¼Œä¸Šè¿° resetTouchState å‡½æ•°é‡ç½® mGroupFlagsï¼Œ
                // disallowIntercept ä¸º falseï¼Œå…è®¸æ‹¦æˆªï¼Œèµ°ä¸‹é¢çš„ onInterceptTouchEvent å‡½æ•°åˆ¤æ–­æ˜¯å¦æ‹¦æˆª
                // å½“ç¬¬äºŒç§æƒ…å†µï¼šmove/upæ—¶ï¼Œè‹¥å‰ä¸€ä¸ªäº‹ä»¶ä¼ åˆ°å­ View æ—¶ï¼Œè°ƒç”¨ getParent().requestDisallowInterceptTouchEvent(true);
                // åˆ™åä¸€ä¸ªäº‹ä»¶åˆ°æ­¤å¤„ï¼ŒdisallowIntercept ä¸º trueï¼Œä¸å…è®¸æ‹¦æˆªï¼Œä¸èµ° onInterceptTouchEvent å‡½æ•°ï¼Œç›´æ¥æ”¾è¡Œ
                // å¦åˆ™ï¼ŒdisallowIntercept ä¸º falseï¼Œå…è®¸æ‹¦æˆªï¼Œèµ° onInterceptTouchEvent å‡½æ•°åˆ¤æ–­æ˜¯å¦æ‹¦æˆª
                // æœ¬ç±»æ­¤å¤„ä»£ç å¾€åï¼Œä¸ä¼šæ”¹åŠ¨ mGroupFlags ä¸­çš„ FLAG_DISALLOW_INTERCEPT æ ‡å¿—ä½ï¼Œ
                // æ‰€ä»¥åªæœ‰å­ View ä¼šæ”¹åŠ¨è¯¥æ ‡å¿—ä½äº†ã€‚

                if (!disallowIntercept) {
                    // down äº‹ä»¶æ‰ä¼šè¿›è¿™é‡Œ
                    intercepted = onInterceptTouchEvent(ev); // 1-2ï¼Œé»˜è®¤è¿”å›falseï¼Œä¸æ‹¦æˆª
                    ev.setAction(action); // restore action in case it was changed
                } else {
                    intercepted = false;
                }
            } else {
                // There are no touch targets and this action is not an initial down
                // so this view group continues to intercept touches.
                intercepted = true;
                // ä¹‹å‰çš„ down äº‹ä»¶ï¼Œå¦‚æœæœ‰å­ View å¤„ç†ï¼Œåˆ™å·²ç»èµ‹å€¼äº† mFirstTouchTargetï¼Œä½¿å…¶ä¸ä¸ºç©ºï¼Œ
                // ä¸ä¼šèµ°è¿™é‡Œï¼›
                // è‹¥ move/up èµ°åˆ°è¿™é‡Œçš„ï¼Œåˆ™ mFirstTouchTarget ä¸ºç©ºï¼Œæ²¡æœ‰å­ View å¤„ç†äº‹ä»¶
                // è¡¨ç¤ºæœ¬ ViewGroup ç»§ç»­å¤„ç†æ­¤æ¬¡ touch äº‹ä»¶ã€‚
            }
	
	// çœç•¥ä»£ç  ......
</pre></td></tr></tbody></table></code></pre></div></div>
<p>æ³¨æ„ï¼š<br />
æ³¨é‡Š1-1å¤„çš„ FLAG_DISALLOW_INTERCEPT å˜é‡ï¼Œå­View å¯ä»¥é€šè¿‡ requestDisallowInterceptTouchEvent æ–¹æ³•ï¼Œè®¾ç½®è¯¥å˜é‡ï¼Œå¹²é¢„ çˆ¶ViewGroup çš„äº‹ä»¶åˆ†å‘è¿‡ç¨‹ï¼ˆACTION_DOWNäº‹ä»¶é™¤å¤–ï¼‰ï¼Œè€Œè¿™å°±æ˜¯æˆ‘ä»¬å¤„ç†æ»‘åŠ¨å†²çªå¸¸ç”¨çš„å…³é”®æ–¹æ³•</p>

<p>ä»£ç æ®µ1.1ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="rouge-code"><pre>//  ViewGroup ç±»

    /**
     * Resets all touch state in preparation for a new cycle.
     */
    private void resetTouchState() {
        clearTouchTargets();
        resetCancelNextUpFlag(this);
        mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
        mNestedScrollAxes = SCROLL_AXIS_NONE;
    }

    @Override
    public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {

        if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) {
            // We're already in this state, assume our ancestors are too
            return;
        }

        if (disallowIntercept) {
            mGroupFlags |= FLAG_DISALLOW_INTERCEPT; 
        } else {
             // é‡ç½®ï¼Œè·Ÿ resetTouchState å‡½æ•°ä¸€è‡´
            mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;
        }

        // Pass it up to our parent
        if (mParent != null) {
            mParent.requestDisallowInterceptTouchEvent(disallowIntercept);
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>mGroupFlags å˜é‡æ˜¯ä¸€ä¸ª int å€¼ï¼Œå…¶ç¬¬ 20 ä½æ˜¯ 0 æˆ–è€… 1ï¼Œå°±ä»£è¡¨ç€ disallowIntercept å˜é‡ä½ false æˆ–è€… trueï¼Œåœ¨ä»£ç ä¸­é€šè¿‡ã€Œ&amp;ã€ä½è¿ç®—æ¥ç¡®è®¤ ï¼šdisallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0ã€‚é‡ç½®åˆ™é€šè¿‡å–åå†ã€Œ&amp;ã€ä½è¿æ¥å®ç°ï¼š mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPTï¼Œè¿™æ · mGroupFlags å˜é‡ç¬¬ 20 ä½ä¼šè¢«ç½®ä¸º 0ã€‚</p>

<h5 id="ç¬¬äºŒæ­¥dispatchtouchevent-å‡½æ•°çš„å‰©ä½™éƒ¨åˆ†éå†å­-viewé€ä¸ªåˆ†å‘">ç¬¬äºŒæ­¥ï¼ŒdispatchTouchEvent å‡½æ•°çš„å‰©ä½™éƒ¨åˆ†ï¼Œéå†å­ Viewï¼Œé€ä¸ªåˆ†å‘</h5>
<p>ä»£ç æ®µ2ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
</pre></td><td class="rouge-code"><pre>    // ......

    TouchTarget newTouchTarget = null;
    boolean alreadyDispatchedToNewTouchTarget = false;
	if (!canceled &amp;&amp; !intercepted) {

        // ......

        if (actionMasked == MotionEvent.ACTION_DOWN
                || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)
                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) {
            final int actionIndex = ev.getActionIndex(); // always 0 for down
            final int idBitsToAssign = split ? 1 &lt;&lt; ev.getPointerId(actionIndex)
                    : TouchTarget.ALL_POINTER_IDS;

            // Clean up earlier touch targets for this pointer id in case they
            // have become out of sync.
            removePointersFromTouchTargets(idBitsToAssign);

            final int childrenCount = mChildrenCount;
            if (newTouchTarget == null &amp;&amp; childrenCount != 0) {
                final float x = ev.getX(actionIndex);
                final float y = ev.getY(actionIndex);
                // Find a child that can receive the event.
                // Scan children from front to back.
                final ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();
                final boolean customOrder = preorderedList == null
                        &amp;&amp; isChildrenDrawingOrderEnabled();
                final View[] children = mChildren;
                // 2-1ï¼Œå€’åºéå†ï¼Œå³ä»æœ€å¤–å±‚çš„ View å¾€å†…å±‚éå†
                for (int i = childrenCount - 1; i &gt;= 0; i--) {
                    final int childIndex = getAndVerifyPreorderedIndex(
                            childrenCount, i, customOrder);
                    final View child = getAndVerifyPreorderedView(
                            preorderedList, children, childIndex);

                    // ã€‚ã€‚ã€‚

                    if (!canViewReceivePointerEvents(child) // 2-2ï¼Œè§¦æ‘¸ç‚¹æ˜¯å¦åœ¨ View çš„èŒƒå›´å†…ï¼Œ
                            || !isTransformedTouchPointInView(x, y, child, null)) { // è¯¥ View æ˜¯å¦åœ¨æ’­æ”¾åŠ¨ç”»ï¼Œå‡ä¸ç¬¦åˆï¼Œå°±ä¸‹ä¸€ä¸ª
                        ev.setTargetAccessibilityFocus(false);
                        continue;
                    }

                    // 2-3ï¼Œé€ä¸ªæŠŠäº‹ä»¶ä¼ é€’ç»™å­ Viewï¼Œè‹¥å…¶ä¸­æŸä¸ªå­ View è¿”å› trueï¼Œåˆ™è¯´æ˜å¤„ç†äº†ç‚¹å‡»äº‹ä»¶ï¼Œè¿›å…¥å¤„ç†åï¼Œbreak æ‰å¾ªç¯
                    if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {
                        // Child wants to receive touch within its bounds.
                        mLastTouchDownTime = ev.getDownTime();
                        if (preorderedList != null) {
                            // childIndex points into presorted list, find original index
                            for (int j = 0; j &lt; childrenCount; j++) {
                                if (children[childIndex] == mChildren[j]) {
                                    mLastTouchDownIndex = j;
                                    break;
                                }
                            }
                        } else {
                            mLastTouchDownIndex = childIndex;
                        }
                        mLastTouchDownX = ev.getX();
                        mLastTouchDownY = ev.getY();
                        // 2-4ï¼Œè®°å½•å¤„ç†äº‹ä»¶çš„å­ View ï¼Œ
		         // åœ¨ addTouchTarget å‡½æ•°å†…éƒ¨ï¼Œèµ‹å€¼ target ç»™ mFirstTouchTargetï¼Œå¹¶è¿”å›å¼•ç”¨ç»™ newTouchTarget
                        newTouchTarget = addTouchTarget(child, idBitsToAssign);
                        alreadyDispatchedToNewTouchTarget = true;
                        break;
                    }

                    // The accessibility focus didn't handle the event, so clear
                    // the flag and do a normal dispatch to all children.
                    ev.setTargetAccessibilityFocus(false);
                }
                if (preorderedList != null) preorderedList.clear();
            }

            // 2-5ï¼Œè‹¥æ²¡æœ‰æ‰¾åˆ°å­ View å¤„ç†äº‹ä»¶ï¼Œåˆ™æŒ‡å‘æœ€æ–°æ·»åŠ çš„å­ View
            if (newTouchTarget == null &amp;&amp; mFirstTouchTarget != null) {
                // Did not find a child to receive the event.
                // Assign the pointer to the least recently added target.
                newTouchTarget = mFirstTouchTarget;
                while (newTouchTarget.next != null) {
                    newTouchTarget = newTouchTarget.next;
                }
                newTouchTarget.pointerIdBits |= idBitsToAssign;
            }
        }
    }
    // åˆ°æ­¤ï¼Œåˆ†å‘äº‹ä»¶ç»™å­Viewçš„å·¥ä½œç»“æŸäº†

    // Dispatch to touch targets.
    if (mFirstTouchTarget == null) {
                // 2-6
                // æ²¡æœ‰å­Viewå¤„ç†äº‹ä»¶
                // No touch targets so treat this as an ordinary view.
                // æ³¨æ„ä¼ å…¥çš„ child å‚æ•°ä¸º nullï¼Œå†…éƒ¨ä¼šè°ƒç”¨ super.dispatchTouchEvent(event);
                // å³èµ° View#dispatchTouchEvent --&gt; onTouchEvent
                handled = dispatchTransformedTouchEvent(ev, canceled, null,
                        TouchTarget.ALL_POINTER_IDS);
            }

</pre></td></tr></tbody></table></code></pre></div></div>

<p>å…ˆçœ‹æ³¨é‡Š2-4å¤„çš„ addTouchTarget å‡½æ•°ï¼š<br />
<strong>å¦‚æœæ‰¾åˆ°äº†å¤„ç†äº‹ä»¶çš„å­ Viewï¼Œå°†å…¶å¼•ç”¨èµ‹å€¼ç»™ mFirstTouchTarget</strong><br />
ä»£ç æ®µ2.1ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>    /**
     * Adds a touch target for specified child to the beginning of the list.
     * Assumes the target child is not already present.
     */
    private TouchTarget addTouchTarget(@NonNull View child, int pointerIdBits) {
        final TouchTarget target = TouchTarget.obtain(child, pointerIdBits);
        target.next = mFirstTouchTarget;
        mFirstTouchTarget = target;
        return target;
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>å†çœ‹æ³¨é‡Š2-6å¤„ã€‚</p>
<h3 id="ç¬¬ä¸‰æ­¥æ²¡æœ‰å­-view-æ¶ˆè´¹äº‹ä»¶èµ°-dispatchtransformedtoucheven-å‡½æ•°">ç¬¬ä¸‰æ­¥ï¼Œæ²¡æœ‰å­ View æ¶ˆè´¹äº‹ä»¶ï¼Œèµ° dispatchTransformedTouchEven å‡½æ•°</h3>
<p>ä»£ç æ®µ3ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        final boolean handled;

        // Canceling motions is a special case.  We don't need to perform any transformations
        // or filtering.  The important part is the action, not the contents.
        final int oldAction = event.getAction();
        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
		 // 3-1
		 // å­ç±»ä¸å­˜åœ¨ï¼Œè°ƒç”¨çˆ¶ç±» Viewï¼ˆæ³¨æ„ä¸æ˜¯çˆ¶è§†å›¾ï¼‰çš„åˆ†å‘é€»è¾‘ï¼Œå¦‚ä»£ ç æ®µ5 ä¸€è‡´
		 // ViewGroup ç»§æ‰¿ View ç±»ï¼Œæ‰€ä»¥ä¹Ÿå…·æœ‰çˆ¶ç±»çš„ç‰¹æ€§
                handled = super.dispatchTouchEvent(event);
            } 
            // ã€‚ã€‚ã€‚

            event.setAction(oldAction);
            return handled;
        }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>æ³¨é‡Š3-1å¤„ï¼Œå› ä¸º child == nullï¼Œèµ°çš„æ˜¯çˆ¶ç±»çš„ super.dispatchTouchEventï¼Œä¹Ÿå°±æ˜¯ View#dispatchTouchEventï¼Œè€Œ dispatchTouchEvent å‡½æ•°æœ€ç»ˆä¼šèµ°åˆ° View#onTouchEventå‡½æ•°ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¦‚æœæ²¡æœ‰å­ View æ¶ˆè´¹äº‹ä»¶ï¼Œå°±è®©æœ¬ ViewGroup æ¥å†³å®šæ˜¯å¦æ¶ˆè´¹äº‹ä»¶ã€‚å…³äº dispatchTouchEvent å’Œ onTouchEvent å‡½æ•°çš„å®ç°ï¼Œå¯æ¥ç€å¾€ä¸‹çœ‹ã€‚</p>

<p>å†å›çœ‹æ³¨é‡Š2-3å¤„ã€‚</p>
<h3 id="ç¬¬å››æ­¥dispatchtransformedtoucheven-å‡½æ•°å¦ä¸€ä¸ªä½œç”¨çœŸæ­£çš„åˆ†å‘äº‹ä»¶ç»™å­-view">ç¬¬å››æ­¥ï¼ŒdispatchTransformedTouchEven å‡½æ•°å¦ä¸€ä¸ªä½œç”¨ï¼ŒçœŸæ­£çš„åˆ†å‘äº‹ä»¶ç»™å­ View</h3>
<p>ä»£ç æ®µ4ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>    private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel,
            View child, int desiredPointerIdBits) {
        final boolean handled;

        // Canceling motions is a special case.  We don't need to perform any transformations
        // or filtering.  The important part is the action, not the contents.
        final int oldAction = event.getAction();
        if (cancel || oldAction == MotionEvent.ACTION_CANCEL) {
            event.setAction(MotionEvent.ACTION_CANCEL);
            if (child == null) {
		 // å­ç±»ä¸å­˜åœ¨ï¼Œè°ƒç”¨çˆ¶ç±» Viewï¼ˆæ³¨æ„ä¸æ˜¯çˆ¶è§†å›¾ï¼‰çš„åˆ†å‘é€»è¾‘ï¼Œå¦‚ä»£ ç æ®µ5 ä¸€è‡´
		 // ViewGroup ç»§æ‰¿ View ç±»ï¼Œæ‰€ä»¥ä¹Ÿå…·æœ‰çˆ¶ç±»çš„ç‰¹æ€§
                handled = super.dispatchTouchEvent(event);
            } else {
		 // 4-1ï¼Œå­ç±»å­˜åœ¨ï¼Œè°ƒç”¨å­ç±»çš„ dispatchTouchEvent åˆ†å‘å‡½æ•°
                handled = child.dispatchTouchEvent(event);
            }
            event.setAction(oldAction);
            return handled;
        }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ¥ç€æ³¨é‡Š4-1å¤„ã€‚</p>
<h3 id="ç¬¬äº”æ­¥äº‹ä»¶ä¼ é€’åˆ°å­-view-çš„åˆ†å‘å‡½æ•°-dispatchtouchevent">ç¬¬äº”æ­¥ï¼Œäº‹ä»¶ä¼ é€’åˆ°å­ View çš„åˆ†å‘å‡½æ•° dispatchTouchEvent</h3>
<p>ä»£ç æ®µ5ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre>    /**
     * Pass the touch screen motion event down to the target view, or this
     * view if it is the target.
     *
     * @param event The motion event to be dispatched.
     * @return True if the event was handled by the view, false otherwise.
     */
    public boolean dispatchTouchEvent(MotionEvent event) {
	// ã€‚ã€‚ã€‚

        if (onFilterTouchEventForSecurity(event)) {
            if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {
                result = true;
            }
            //noinspection SimplifiableIfStatement
            ListenerInfo li = mListenerInfo;
            if (li != null &amp;&amp; li.mOnTouchListener != null
                    &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                    &amp;&amp; li.mOnTouchListener.onTouch(this, event)) { // 5-1ï¼Œä¼˜å…ˆ onTouch å‡½æ•°
                result = true;
            }

            if (!result &amp;&amp; onTouchEvent(event)) { // 5-2ï¼Œå…¶æ¬¡ onTouchEvent å‡½æ•°
                result = true;
            }
        }

	// ã€‚ã€‚ã€‚
        return result;
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ¥ç€æ³¨é‡Š5-2å¤„ã€‚</p>
<h5 id="ç¬¬å…­æ­¥äº‹ä»¶ä¼ é€’åˆ°å­-view-çš„-ontouchevent-å‡½æ•°">ç¬¬å…­æ­¥ï¼šäº‹ä»¶ä¼ é€’åˆ°å­ View çš„ onTouchEvent å‡½æ•°</h5>
<p>ä»£ç æ®µ6ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre></td><td class="rouge-code"><pre>    public boolean onTouchEvent(MotionEvent event) {
        final float x = event.getX();
        final float y = event.getY();
        final int viewFlags = mViewFlags;
        final int action = event.getAction();
	   // 6-1ï¼Œåªè¦è®¾ç½®ç‚¹å‡»æˆ–é•¿æŒ‰ç›‘å¬çš„å…¶ä¸­ä¸€ä¸ªï¼Œå°±ä¼šå¤„ç†äº‹ä»¶å¹¶è¿”å› true
        final boolean clickable = ((viewFlags &amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE;

	  // ã€‚ã€‚ã€‚

        if (clickable || (viewFlags &amp; TOOLTIP) == TOOLTIP) {
            switch (action) {
                case MotionEvent.ACTION_UP:
		     // ã€‚ã€‚ã€‚
                        if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                            // This is a tap, so remove the longpress check
                            removeLongPressCallback();

                            // Only perform take click actions if we were in the pressed state
                            if (!focusTaken) {
                                // Use a Runnable and post this rather than calling
                                // performClick directly. This lets other visual state
                                // of the view update before click actions start.
                                if (mPerformClick == null) {
                                    mPerformClick = new PerformClick();
                                }
                                if (!post(mPerformClick)) {
                                    performClickInternal(); // 6-2 Up äº‹ä»¶æ—¶ï¼Œæ‰§è¡Œå¤„ç†ç‚¹å‡»çš„é€»è¾‘
                                }
                            }
                        }

		     // ã€‚ã€‚ã€‚
                    break;

                case MotionEvent.ACTION_DOWN:
		     // ã€‚ã€‚ã€‚
                    break;

                case MotionEvent.ACTION_CANCEL:
		     // ã€‚ã€‚ã€‚
                    break;

                case MotionEvent.ACTION_MOVE:
		     // ã€‚ã€‚ã€‚
                    break;
            }

            return true;
        }

        return false;
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ¥ç€æ³¨é‡Š6-2ï¼Œ</p>
<h5 id="ç¬¬ä¸ƒæ­¥performclickinternal-å‡½æ•°å¤„ç†ç‚¹å‡»çš„é€»è¾‘">ç¬¬ä¸ƒæ­¥ï¼ŒperformClickInternal å‡½æ•°å¤„ç†ç‚¹å‡»çš„é€»è¾‘</h5>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>    private boolean performClickInternal() {
        // Must notify autofill manager before performing the click actions to avoid scenarios where
        // the app has a click listener that changes the state of views the autofill service might
        // be interested on.
        notifyAutofillManagerOnClick();

        return performClick();// æ¥ç€è¿™çœ‹
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>    public boolean performClick() {
        // We still need to call this method to handle the cases where performClick() was called
        // externally, instead of through performClickInternal()
        notifyAutofillManagerOnClick();

        final boolean result;
        final ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnClickListener != null) {
            playSoundEffect(SoundEffectConstants.CLICK);
            li.mOnClickListener.onClick(this); // 7-1ï¼Œå›è°ƒ
            result = true;
        } else {
            result = false;
        }

        sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);

        notifyEnterOrExitForAutoFillIfNeeded(true);

        return result;
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>æ³¨é‡Š7-1å¤„ï¼Œæ‰§è¡Œäº† mOnClickListener çš„ onClick å‡½æ•°ï¼Œ<br />
å°±æ˜¯é€šè¿‡ View çš„å‡½æ•° setOnClickListener è®¾ç½®è¿›æ¥çš„ï¼Œè¯¦æƒ…ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>    public void setOnClickListener(@Nullable OnClickListener l) {
        if (!isClickable()) {
            setClickable(true);
        }
        getListenerInfo().mOnClickListener = l;
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<p>åˆ°æ­¤ï¼ŒåŸºæœ¬æµç¨‹å°±èµ°å®Œäº†ã€‚<br /></p>

<ul>
  <li>æµç¨‹å›¾ï¼š
æˆ‘è‡ªå·±ç”»çš„æµç¨‹å›¾æœ‰ç‚¹ä¸‘ï¼Œè¿™é‡Œå…ˆå»<a href="https://jsonchao.github.io/2018/10/17/Androidè§¦æ‘¸äº‹ä»¶ä¼ é€’æœºåˆ¶/">è¯¥é“¾æ¥</a>çš„æ–‡ç« çœ‹é‡Œé¢çš„æµç¨‹å›¾ï¼Œç”»å¾—éå¸¸å¥½ï¼Œå€¼å¾—å­¦ä¹ ï¼
<br /></li>
</ul>

<h1 id="å°ç»“ä¸€ä¸‹">å°ç»“ä¸€ä¸‹</h1>

<h4 id="viewgroup--dispatchtouchevent-å‡½æ•°çš„æ­¥éª¤ç»†èŠ‚">ViewGroup # dispatchTouchEvent å‡½æ•°çš„æ­¥éª¤ç»†èŠ‚</h4>

<ul>
  <li>1âƒ£ï¸ é‡ç½®ï¼šdown äº‹ä»¶ï¼Ÿ
    <ul>
      <li>é‡ç½® ç›®æ ‡å­Viewï¼ŒmFirstTouchTarget == null</li>
      <li>é‡ç½® ä¸æ‹¦æˆªflagï¼ŒmGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT</li>
    </ul>
  </li>
  <li>2âƒ£ï¸ æ‹¦æˆªåˆ¤æ–­ï¼Œæ¡ä»¶ä¸€ï¼šdown äº‹ä»¶ï¼Ÿ
    <ul>
      <li>disallowIntercept é‡ç½®ä¸º falseï¼Œèµ° 4âƒ£ï¸ intercepted = onInterceptTouchEvent(ev)ï¼Œé»˜è®¤è¿”å› false</li>
    </ul>
  </li>
  <li>3âƒ£ï¸ æ‹¦æˆªåˆ¤æ–­ï¼Œæ¡ä»¶äºŒï¼šmove/upäº‹ä»¶ï¼Œæœ‰ç›®æ ‡å­View
    <ul>
      <li>disallowIntercept åœ¨ down äº‹ä»¶æ—¶é‡ç½®ä¸º falseï¼Œèµ° 4âƒ£ï¸ intercepted = onInterceptTouchEvent(ev)ï¼Œé»˜è®¤è¿”å› false</li>
      <li>è‹¥ä¸Šä¸€ä¸ªäº‹ä»¶ä¼ åˆ°ç›®æ ‡å­Viewæ—¶ï¼Œå­View è°ƒç”¨getParent().requestDisallowInterceptTouchEvent(true)ï¼Œå°† disallowInterceptç½®ä¸º trueï¼Œèµ° 5âƒ£ï¸ intercepted = false</li>
    </ul>
  </li>
  <li>6âƒ£ï¸ åˆ†å‘ï¼šintercepted == false
    <ul>
      <li>è½ç‚¹åˆ¤æ–­ï¼šè‹¥åœ¨è½ç‚¹å†…ï¼Œåˆ™åˆ†å‘</li>
      <li>åˆ†å‘äº‹ä»¶ç»™å­Viewï¼Œchild.dispatchTouchEvent</li>
      <li>è‹¥è¿”å› trueï¼Œåˆ™å°†è¯¥ child è®°å½•ä¸º ç›®æ ‡å­View</li>
    </ul>
  </li>
  <li>7âƒ£ï¸ è‡ªæ¶ˆåŒ–ï¼šæ²¡æœ‰ç›®æ ‡å­Viewï¼ŒmFirstTouchTarget == null
    <ul>
      <li>dispatchTransformedTouchEvent(ev, canceled, null, â€¦ ) ç¬¬ä¸‰ä¸ªå‚æ•° child ä¸º null
        <ul>
          <li>if(child == null)  super.dispatchTouchEvent â€“&gt; View#dispatchTouchEvent â€“&gt; View#onTouchEvent</li>
          <li>å³èµ° onTouchEvent å‡½æ•°æ¥ç¡®å®šè‡ªèº«æ˜¯å¦æ¶ˆåŒ–è¿™ä¸ªäº‹ä»¶</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h4 id="ä¸€æ¬¡äº‹ä»¶åºåˆ—åœ¨-viewgroupdispatchtouchevent-å‡½æ•°çš„è¿‡ç¨‹-">ä¸€æ¬¡äº‹ä»¶åºåˆ—åœ¨ ViewGroup#dispatchTouchEvent å‡½æ•°çš„è¿‡ç¨‹ <br /></h4>
<p>| äº‹ä»¶  | æ­¥éª¤  | å¤‡æ³¨  |
|:â€”â€”â€”-|:â€”â€”â€”-:|:â€”â€”â€”-|
| down    | 1âƒ£ï¸ 2âƒ£ï¸ 4âƒ£ï¸ 6âƒ£ï¸    |  è®°å½•æ¶ˆè´¹äº‹ä»¶çš„ç›®æ ‡å­View    |
| move    | 3âƒ£ï¸ 4âƒ£ï¸ 6âƒ£ï¸     |     |
|  â€¦    | 3âƒ£ï¸ 4âƒ£ï¸ 6âƒ£ï¸     |     |
| move    | 3âƒ£ï¸ 4âƒ£ï¸ 6âƒ£ï¸     |  ç›®æ ‡å­Viewä¸­ï¼Œè¯·æ±‚ä¸æ‹¦æˆª   |
| move    | 3âƒ£ï¸ 5âƒ£ï¸ 6âƒ£ï¸     |   ä¹‹åéƒ½ä¸èµ°æ­¥éª¤4âƒ£ï¸ï¼Œèµ°æ­¥éª¤5âƒ£ï¸ intercepted = false ï¼Œç›´æ¥ä¸æ‹¦æˆª  |
| â€¦    | 3âƒ£ï¸ 5âƒ£ï¸ 6âƒ£ï¸     |     |
| up    | 3âƒ£ï¸ 5âƒ£ï¸ 6âƒ£ï¸     |     |</p>

<p><br /></p>
<ul>
  <li>è‹¥è¯¥ ViewGroup æ²¡æœ‰å­Viewï¼Œä¸”è¢«è§¦æ‘¸ç‚¹å‘½ä¸­ ï¼Œåˆ™è¿‡ç¨‹æ­¥éª¤å¦‚ä¸‹ï¼š</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: left">äº‹ä»¶</th>
      <th style="text-align: center">æ­¥éª¤</th>
      <th style="text-align: left">å¤‡æ³¨</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">down</td>
      <td style="text-align: center">1âƒ£ï¸ 2âƒ£ï¸ 4âƒ£ï¸ 6âƒ£ï¸ 7âƒ£ï¸</td>
      <td style="text-align: left">æ²¡æœ‰ç›®æ ‡å­Viewï¼Œèµ° onTouchEvent å‡½æ•° ï¼Œè‹¥è¿”å› falseï¼Œä¸å¤„ç†äº‹ä»¶ï¼Œåˆ™è¯¥ViewGroupè‡ªèº«ä¸ä¼šè¢«åŠ å…¥åˆ°çˆ¶å®¹å™¨çš„ mFirstTouchTarget ä¸­ï¼Œåç»­çš„  move/up äº‹ä»¶ï¼Œéƒ½ä¼šç›´æ¥èµ°7âƒ£ï¸ï¼Œè¿”å› falseï¼ŒæŠŠäº‹ä»¶è¿”å›çˆ¶å®¹å™¨å¤„ç†</td>
    </tr>
    <tr>
      <td style="text-align: left">move</td>
      <td style="text-align: center">7âƒ£ï¸</td>
      <td style="text-align: left">Â </td>
    </tr>
    <tr>
      <td style="text-align: left">â€¦</td>
      <td style="text-align: center">7âƒ£ï¸</td>
      <td style="text-align: left">Â </td>
    </tr>
    <tr>
      <td style="text-align: left">up</td>
      <td style="text-align: center">7âƒ£ï¸</td>
      <td style="text-align: left">Â </td>
    </tr>
  </tbody>
</table>

<h4 id="view--dispatchtouchevent-å‡½æ•°çš„å¤§è‡´æ­¥éª¤">View # dispatchTouchEvent å‡½æ•°çš„å¤§è‡´æ­¥éª¤</h4>
<ul>
  <li>onTouch å‡½æ•°å¤„ç†
    <ul>
      <li>è¿”å› trueï¼Œå‡½æ•°ç»“æŸ</li>
    </ul>
  </li>
  <li>onTouchEvent å‡½æ•°å¤„ç†
    <ul>
      <li>è®¾ç½®äº†ç‚¹å‡»æˆ–é•¿æŒ‰çš„ç›‘å¬ï¼Œå¤„ç†äº‹ä»¶å¹¶è¿”å› trueï¼Œå‡½æ•°ç»“æŸ
        <ul>
          <li>case MotionEvent.ACTION_UPï¼šperformClickInternal</li>
          <li>case MotionEvent.ACTION_DOWNï¼šcheckForLongClick â€“ CheckForLongPress#run â€“ performLongClick</li>
          <li>è¿”å› true</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<p><br /></p>
<ul>
  <li>å‚è€ƒçš„é“¾æ¥ï¼š<br />
<a href="https://jsonchao.github.io/2018/10/17/Androidè§¦æ‘¸äº‹ä»¶ä¼ é€’æœºåˆ¶/">æ–‡ç« ä¸€ï¼Œç®€æ˜ç²¾ç¡®</a><br />
<a href="https://www.jianshu.com/p/238d1b753e64">æ–‡ç« äºŒï¼Œè¯¦ç»†ä¸­å¸¦çš®</a><br />
<a href="https://www.jianshu.com/p/fc0590afb1bf">æ–‡ç« ä¸‰ï¼Œä»Demoçš„è§’åº¦</a>
<a href="https://blog.csdn.net/carson_ho/article/details/54136311">æ–‡ç« å››ï¼Œè¡¨æ ¼å’Œæµç¨‹å›¾å¾ˆæ¸…æ™°ï¼Œæ°´å¹³è¿œè¶…æˆ‘çš„ä¸€ç¯‡ï¼šAndroidäº‹ä»¶åˆ†å‘æœºåˆ¶ è¯¦è§£æ”»ç•¥ï¼Œæ‚¨å€¼å¾—æ‹¥æœ‰</a></li>
</ul>
:ET