I"°8<h1 id="æ€»è§ˆ">æ€»è§ˆ</h1>
<p>Handler çš„å·¥ä½œæµç¨‹</p>
<ul>
  <li>åˆ›å»ºï¼Œç»‘å®šçº¿ç¨‹ç‰¹æœ‰çš„ Looper å®ä¾‹</li>
  <li>å‘æ¶ˆæ¯ Handler#sendMessage æˆ– Handler#post</li>
  <li>å…¥é˜Ÿ MessageQueue#enqueueMessage()</li>
  <li>æ¶ˆæ¯å¾ªç¯  Looper.loop()</li>
  <li>åˆ†å‘å¤„ç†  Handler#dispatchMessage</li>
</ul>

<h1 id="handler-çš„ç”¨æ³•ç¤ºä¾‹">Handler çš„ç”¨æ³•ç¤ºä¾‹</h1>

<p>åˆ›å»ºï¼Œå®šä¹‰å¤„ç†é€»è¾‘ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre>	// åˆ›å»ºçš„æ—¶å€™ï¼Œéœ€è¦å®ç° handleMessage å‡½æ•°
	Handler mHandler = new Handler(){
		@Override
		public void handleMessage(Message msg) {
			// do something                        
		}
	};
</pre></td></tr></tbody></table></code></pre></div></div>

<p>å‘æ¶ˆæ¯ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>	// å‘é€ä¸€ä¸ªæ¶ˆæ¯
	Message message = new Message();
	message.obj = "I am a message";
	mHandler.sendMessage(message);

	// post ä¸€ä¸ªçº¿ç¨‹
	mHandler.post(new Runnable() {
		@Override
		public void run() {
			 LogUtil.e("å½“å‰çº¿ç¨‹ï¼š" + Thread.currentThread().getName());
		}
	});
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="æ¶ˆæ¯å‘é€çš„ä¸¤ç§æ–¹å¼-sendmessage-å’Œ-post">æ¶ˆæ¯å‘é€çš„ä¸¤ç§æ–¹å¼ sendMessage å’Œ post</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>// ä»£ç æ®µ0:
// Handler ç±»

    public final boolean sendMessage(Message msg)
    {
        return sendMessageDelayed(msg, 0);
    }

    public final boolean sendMessageDelayed(Message msg, long delayMillis)
    {
        if (delayMillis &lt; 0) {
            delayMillis = 0;
        }
        return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);
    }

    public boolean sendMessageAtTime(Message msg, long uptimeMillis) {
        MessageQueue queue = mQueue;
        if (queue == null) {
            RuntimeException e = new RuntimeException(
                    this + " sendMessageAtTime() called with no mQueue");
            Log.w("Looper", e.getMessage(), e);
            return false;
        }
        return enqueueMessage(queue, msg, uptimeMillis);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>åˆ°æ­¤å¯çŸ¥ï¼Œæœ€ç»ˆè°ƒç”¨äº† enqueueMessage å‡½æ•°è¿›è¡Œå…¥é˜Ÿå¤„ç†ã€‚</p>

<p>å†çœ‹ post å‡½æ•°æºç ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>// ä»£ç æ®µ0.1:
// Handler ç±» 

   public final boolean post(Runnable r)
    {
       return  sendMessageDelayed(getPostMessage(r), 0);
    }

    private static Message getPostMessage(Runnable r) {
        Message m = Message.obtain();
        m.callback = r;
        return m;
    }

    public static Message obtain() {
        synchronized (sPoolSync) {
            if (sPool != null) {
                Message m = sPool; // ä»çº¿ç¨‹æ± é‡Œå–ä¸€ä¸ª Message å®ä¾‹
                sPool = m.next;
                m.next = null;
                m.flags = 0; // clear in-use flag
                sPoolSize--;
                return m;
            }
        }
        return new Message();
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>post å‡½æ•°æäº¤çš„ Runnable å®ä¾‹ï¼Œä¼šè¢«æ”¾å…¥ Message å®ä¾‹çš„æˆå‘˜å˜é‡ callback ä¸­ï¼Œæ¥ç€è°ƒç”¨ 
sendMessageDelayed å‡½æ•°ç»§ç»­æµç¨‹ï¼Œä»¥ Message å®ä¾‹çš„å½¢å¼ç»§ç»­ä¼ é€’ã€‚<br /></p>

<p>åˆ°æ­¤å¯çŸ¥ï¼Œæ— è®ºè°ƒç”¨ sendMessage å‡½æ•°è¿˜æ˜¯ post å‡½æ•°ï¼Œæœ€ç»ˆéƒ½ä¼šè°ƒç”¨ sendMessageDelayed å‡½æ•°ï¼Œè¿›è€Œè°ƒç”¨ enqueueMessage å‡½æ•°æŠŠæ¶ˆæ¯ msg å…¥é˜Ÿã€‚</p>

<h1 id="æ¶ˆæ¯å…¥é˜Ÿ-messagequeueenqueuemessage">æ¶ˆæ¯å…¥é˜Ÿ MessageQueue#enqueueMessage()</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>// ä»£ç æ®µ1:
// Handler ç±»

    private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) {
        msg.target = this; //å…¥é˜Ÿå‰ï¼Œè®°å½•æ‰€å±çš„ handler
        if (mAsynchronous) {
            msg.setAsynchronous(true);
        }
        return queue.enqueueMessage(msg, uptimeMillis);
    }
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
</pre></td><td class="rouge-code"><pre>// ä»£ç æ®µ2:
// MessageQueue ç±»

    boolean enqueueMessage(Message msg, long when) {
        if (msg.target == null) {
            throw new IllegalArgumentException("Message must have a target.");
        }
        if (msg.isInUse()) {
            throw new IllegalStateException(msg + " This message is already in use.");
        }

        synchronized (this) {
            if (mQuitting) {
                IllegalStateException e = new IllegalStateException(
                        msg.target + " sending message to a Handler on a dead thread");
                Log.w(TAG, e.getMessage(), e);
                msg.recycle();
                return false;
            }

            msg.markInUse();
            msg.when = when;
            Message p = mMessages; // æ‹¿åˆ°è¡¨å¤´
            boolean needWake;
            if (p == null || when == 0 || when &lt; p.when) {
		// å¦‚æœè¡¨å¤´ä¸ºç©º or å»¶è¿Ÿæ—¶é—´ä¸º0 or å»¶è¿Ÿæ—¶é—´æ¯”è¡¨å¤´æ—¶é—´å°‘
		// åˆ™æ’å…¥è¡¨å¤´

                // New head, wake up the event queue if blocked.
                msg.next = p;
                mMessages = msg;
                needWake = mBlocked;
            } else {
		// å¦åˆ™æ’å…¥ä¸­é—´

                // Inserted within the middle of the queue.  Usually we don't have to wake
                // up the event queue unless there is a barrier at the head of the queue
                // and the message is the earliest asynchronous message in the queue.
                needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous();
                Message prev;
                for (;;) {
                    prev = p; 
                    p = p.next; // ä»è¡¨å¤´å¾€åéå†
                    if (p == null || when &lt; p.when) { // æŒ‰ when çš„æ—©æ™šæ’åºï¼Œè‹¥whenç›¸ç­‰ï¼Œåå…¥é˜Ÿçš„æ’åé¢ï¼Œä¾‹å¦‚ï¼Œ2ï¼Œ3ï¼Œ5ï¼›å…¥é˜Ÿæ˜¯ 3ï¼Œé‚£ä¹ˆå¾ªç¯åˆ° p.when == 5 çš„æ—¶å€™breakï¼›
                        break;
                    }
                    if (needWake &amp;&amp; p.isAsynchronous()) {
                        needWake = false;
                    }
                }
                msg.next = p; // invariant: p == prev.next
                prev.next = msg; // å®Œæˆæ’å…¥
            }

            // We can assume mPtr != 0 because mQuitting is false.
            if (needWake) {
                nativeWake(mPtr);
            }
        }
        return true;
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>å¯çŸ¥ queue ä¸­ï¼Œmessage ä»¥é“¾è¡¨çš„å½¢å¼å­˜å‚¨ï¼ŒæŒ‰æ‰§è¡Œäº‹ä»¶çš„æ—©æ™šï¼Œå³ when ç”±å°åˆ°å¤§æ’åºï¼Œè‹¥whenç›¸ç­‰ï¼Œåå…¥é˜Ÿçš„æ’åé¢ã€‚</p>

<h1 id="æ¶ˆæ¯å¾ªç¯-looperloop">æ¶ˆæ¯å¾ªç¯ Looper.loop()</h1>
<p>åœ¨æ–‡ç«   [[Handler å¦‚ä½•ç»‘å®š Thread çº¿ç¨‹ ]] ä¸­ï¼Œå¯çŸ¥ new Handler ä¹‹å‰ï¼Œå½“å‰çº¿ç¨‹ä¼šé€šè¿‡å§”æ‰˜ Looper.prapare() ï¼Œnew ä¸€ä¸ª Looper å®ä¾‹å¹¶å­˜åˆ°å½“å‰çº¿ç¨‹çš„çº¿ç¨‹æœ¬åœ° map ï¼ˆå³ å½“å‰çº¿ç¨‹å®ä¾‹çš„æˆå‘˜å˜é‡ threadLocalsï¼‰ä¸­ï¼Œä»è€Œå®ç°ç»‘å®šå½“å‰çº¿ç¨‹ ã€‚<br /></p>

<p>Looper.prapare() ä¹‹åï¼Œæ‰§è¡Œ new Handler()ï¼Œç„¶åå†æ‰§è¡Œ Looper.loop() å¼€å¯æ¶ˆæ¯å¾ªç¯ï¼Œä¸æ–­ä»é˜Ÿåˆ—é‡Œå–æ¶ˆæ¯ã€‚å¦åˆ™åˆšåˆš new çš„ Handler æ”¶ä¸åˆ°æ¶ˆæ¯ã€‚ <br /></p>

<p>å»çœ‹ Looper.loop() å‡½æ•°æºç ï¼š</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="rouge-code"><pre>// ä»£ç æ®µ3:
// Looper ç±»

    public static void loop() {
        final Looper me = myLooper();
        if (me == null) {
            throw new RuntimeException("No Looper; Looper.prepare() wasn't called on this thread.");
        }
        final MessageQueue queue = me.mQueue;

	// ã€‚ã€‚ã€‚ ç•¥

        for (;;) {
            // 3-0 å¤„ï¼Œå–å‡ºæ¶ˆæ¯
            Message msg = queue.next(); // might block
            if (msg == null) {
                // No message indicates that the message queue is quitting.
                return;
            }

	    //ã€‚ã€‚ã€‚

            final long dispatchStart = needStartTime ? SystemClock.uptimeMillis() : 0;
            final long dispatchEnd;
            try {
		// 3-1 åˆ†å‘ç»™æ‰€å±çš„ Handler å®ä¾‹ï¼Œå‚è€ƒä»£ç æ®µ1
                msg.target.dispatchMessage(msg);
                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : 0;
            } finally {
                if (traceTag != 0) {
                    Trace.traceEnd(traceTag);
                }
            }

	    // ã€‚ã€‚ã€‚

            msg.recycleUnchecked();
        }
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>3-0 å¤„ï¼Œå–å‡ºæ¶ˆæ¯ï¼Œå¹¶åšä¸€äº›åˆ¤æ–­ï¼Œæ²¡é—®é¢˜å°±ç»§ç»­ã€‚
3-1å¤„ï¼Œmsg.target å¾—åˆ°çš„æ˜¯ msg æ‰€å±çš„ Handler å®ä¾‹ï¼Œ ä»£ç æ®µ1çš„ Handler ç±»çš„ enqueueMessage å‡½æ•°æŠŠæ¶ˆæ¯å…¥é˜Ÿä¹‹å‰ï¼Œèµ‹å€¼è‡ªèº« this ç»™ msg.target ã€‚
æ‰€ä»¥ï¼Œmsg.target.dispatchMessage(msg) è°ƒç”¨çš„æ˜¯ Handler ç±»çš„ dispatchMessage å‡½æ•°ã€‚
æ¥ç€çœ‹ dispatchMessage æºç ï¼š</p>

<h1 id="æ¶ˆæ¯å¤„ç†-handlerdispatchmessage">æ¶ˆæ¯å¤„ç† Handler#dispatchMessage</h1>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>// ä»£ç æ®µ4
// Handler ç±»

    public void dispatchMessage(Message msg) {
        if (msg.callback != null) { 
	     // 4-1 è¡¨ç¤ºç”± post å‡½æ•°å‘é€çš„ Runnableï¼Œå‚è€ƒä»£ç æ®µ0.1ï¼Œpost å‡½æ•°çš„æºç å¯çŸ¥
            handleCallback(msg);
        } else {
            if (mCallback != null) { 
                if (mCallback.handleMessage(msg)) { // 4-2 å¦‚æœæœ‰å›è°ƒå¤„ç†äº†ï¼Œç›´æ¥è¿”å›
                    return;
                }
            }
            handleMessage(msg); //4-3 æœ€åæ‰å«ç»™ handleMessage å‡½æ•°
        }
    }

    private static void handleCallback(Message message) {
        message.callback.run();
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>å€¼å¾—æ³¨æ„çš„æ˜¯ 4-2 å¤„ï¼ŒmCallback  æ˜¯åœ¨æ„é€ å‡½æ•°ä¼ è¿›æ¥çš„ã€‚</p>

<p>æ„é€ å‡½æ•° å’Œ Callback çš„å®šä¹‰ï¼š</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>// ä»£ç æ®µ4.1
// Handler ç±»

    public Handler(Callback callback) {
        this(callback, false);
    }

    public Handler(Callback callback, boolean async) {
	// ã€‚ã€‚ã€‚

        mLooper = Looper.myLooper();
        if (mLooper == null) {
            throw new RuntimeException(
                "Can't create handler inside thread " + Thread.currentThread()
                        + " that has not called Looper.prepare()");
        }
        mQueue = mLooper.mQueue;
        mCallback = callback;
        mAsynchronous = async;
    }

    public interface Callback {
        /**
         * @param msg A {@link android.os.Message Message} object
         * @return True if no further handling is desired
         */
        public boolean handleMessage(Message msg);
    }
</pre></td></tr></tbody></table></code></pre></div></div>
<p>ä»£ç æ®µ4ä¸­ï¼Œå¦‚æœ mCallback.HandleMessage è¿”å› trueï¼Œå°±è¡¨ç¤ºå¤„ç†äº†ï¼Œå°±ä¸ä¼šèµ° 4-3 å¤„çš„ handleMessage å‡½æ•°ã€‚</p>

<h1 id="æ€»ç»“">æ€»ç»“</h1>
<p>Handler çš„å·¥ä½œæµç¨‹<br /></p>
<ul>
  <li>åˆ›å»ºï¼Œç»‘å®šçº¿ç¨‹ç‰¹æœ‰çš„ Looper å®ä¾‹
    <ul>
      <li>æ„é€ å‡½æ•°å†…ï¼ŒmLooper = Looper.myLooper()
        <ul>
          <li>Looper ç±»çš„é™æ€å‡½æ•°ä¼š new ä¸€ä¸ª Looper å®ä¾‹ï¼Œå­˜åˆ°å½“å‰çº¿ç¨‹ä¸­</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>å‘æ¶ˆæ¯ Handler#sendMessage æˆ– Handler#post
    <ul>
      <li>post çš„ Runnableï¼Œè¢« getPostMessage å‡½æ•°åŒ…è£…ç§° message
        <ul>
          <li>Runnable è¢«èµ‹å€¼åˆ° message çš„æˆå‘˜å˜é‡ï¼Œm.callback = r;</li>
        </ul>
      </li>
      <li>ä¸¤ç§æ–¹æ³•ï¼Œæœ€ç»ˆéƒ½æ˜¯è°ƒç”¨ sendMessageDelayed
        <ul>
          <li>msg.target = this; //å…¥é˜Ÿå‰ï¼Œè®°å½•æ‰€å±çš„ handler</li>
          <li>queue.enqueueMessage(msg, uptimeMillis);</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>å…¥é˜Ÿ MessageQueue#enqueueMessage()
    <ul>
      <li>ä»¥é“¾è¡¨å½¢å¼å­˜å‚¨</li>
      <li>å¦‚æœè¡¨å¤´ä¸ºç©º or å»¶è¿Ÿæ—¶é—´ä¸º0 or å»¶è¿Ÿæ—¶é—´æ¯”è¡¨å¤´æ—¶é—´å°‘ï¼Œæ’å…¥è¡¨å¤´</li>
      <li>å¦åˆ™ï¼Œæ’å…¥é˜Ÿåˆ—ä¸­é—´æˆ–æœ«å°¾ï¼Œä¿è¯æŒ‰ when ä»å°åˆ°å¤§æ’åºå³å¯ï¼Œwhen ç›¸åŒçš„ï¼Œåæ¥åå¤„ç†</li>
    </ul>
  </li>
  <li>æ¶ˆæ¯å¾ªç¯  Looper.loop()
    <ul>
      <li>for : msg = queue.next();</li>
      <li>msg.target.dispatchMessage(msg);ï¼‰</li>
    </ul>
  </li>
  <li>åˆ†å‘å¤„ç†  Handler#dispatchMessage
    <ul>
      <li>post Runnable â€“ handleCallback(msg); â€“ callback.run</li>
      <li>mCallback.handleMessage(msg)</li>
      <li>handleMessage(msg)</li>
    </ul>
  </li>
</ul>
:ET